# 并查集



用于处理不相交集合 (disjoint sets) 合并及查找的问题，典型应用有连通分量检测，环路检测等



## 模板

```python
class UnionFind:
    def __init__(self, grid):
        
        row = len(grid)
        col = len(grid[0])
        self.root = [i for i in range(row * col)]
            
            
        def find(self, x):
            if x != self.root[x]:
                self.root[x] = self.find(self.root[x])
            return self.root[x]
        
        def union(self, x, y):
            self.root[self.find(x)] = self.find(y)        
```



优化（基于权重优化）

```python
class UnionFind:
    def __init__(self, grid):
        
        row = len(grid)
        col = len(grid[0])
        self.root = [i for i in range(row * col)]
        self.rank = [0 for _ in range(row * col)]

            
            
        def find(self, x): # quick find
            if x != self.root[x]:
                self.root[x] = self.find(self.root[x])
            return self.root[x]

            
        
        def union(self, x, y):
            rootx = self.find(x)
            rooty = self.find(y)
            if rootx != rooty: # quick union 防止树太高： 比较两个数的高；把矮的树连接到高的树上；使得树的高度最低；
                if self.rank[rootx] > self.rank[rooty]:
                    self.root[rooty] = rootx
                elif self.rank[rootx] < self.rank[rooty]:
                    self.root[rootx] = rooty
                else:
                    self.root[rooty] = rootx
                    self.rank[rootx] += 1
```



## ✅[省份数量 x](https://leetcode-cn.com/problems/number-of-provinces/)

```python
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:

        if not isConnected: return 0
        n = len(isConnected)
        res = [i for i in range(n)]

        def find(x):
            if x != res[x]:
                res[x] = find(res[x])
            return res[x]
        
        def union(x, y):
            rootx = find(x)
            rooty = find(y)

            if rootx != rooty:
                res[rootx] = rooty
        
        for i in range(n):
            for j in range(i + 1, n):
                if isConnected[i][j] == 1:
                    union(i, j)
        
        return sum( int(i == res[i]) for i in range(n))
```



## ✅[冗余连接 x](https://leetcode-cn.com/problems/redundant-connection/)

在一棵树中，边的数量比节点的数量少 1。如果一棵树有 N 个节点，则这棵树有N−1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 N

树是一个连通且无环的无向图，在树中多了一条附加的边之后就会出现环，因此附加的边即为导致环出现的边。

可以通过并查集寻找附加的边。初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。

如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。

如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。

```Python
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        res = [i for i in range(n+1)] # 0->n, 每个点一个，range(1, n+1)会错位，

        def find(x):
            if x != res[x]:
                res[x] = find(res[x])
            return res[x]
        
        def union(x, y):
            rootx, rooty = find(x), find(y)
            if rootx != rooty:
                res[rootx] = rooty
        
        for node1, node2 in edges:
            if find(node1) != find(node2):
                union(node1, node2)
            else:
                return [node1, node2]
        return []
```



## ✅[账户合并](https://leetcode-cn.com/problems/accounts-merge/)

```Python
class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        
        parent = []
        rank = []
        
        def find(x):
            if parent[parent[x]] != parent[x]:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x, y):
            px, py = find(x), find(y)
            if px == py:
                return
            if rank[px] > rank[py]:
                parent[py] = px
            elif rank[px] < rank[py]:
                parent[px] = py
            else:
                parent[px] = py
                rank[py] += 1
            return
        
        email2name = {}
        email2idx = {}
        i = 0
        for acc in accounts:
            for email in acc[1:]:
                email2name[email] = acc[0]
                if email not in email2idx:
                    parent.append(i)
                    rank.append(1)
                    email2idx[email] = i
                    i += 1
                union(email2idx[acc[1]], email2idx[email])
        
        result = collections.defaultdict(list)
        for email in email2name:
            result[find(email2idx[email])].append(email)
        
        return [[email2name[s[0]]] + sorted(s) for s in result.values()]
```



## ✅[最长连续序列 x](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

```Python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        parent = {num : num for num in nums} # 刚开始每个nums都不连通,所以rootnum = num
        length = {num : 1 for num in nums} # 刚开始每个人只有一个元素

        def find(x):
            if x != parent[x]:
                parent[x] = find(parent[x])
            return parent[x]
        
…            if num + 1 in parent:
                union(num+1, num)
            if num - 1 in parent:
                union(num-1, num)
            max_len = max(max_len, length[parent[num]])

        return max_len   
```



## ✅[最小危险值路径（最小生成树）](https://www.lintcode.com/problem/minimum-risk-path/description)

算法 1: [Kruskal's algorithm](https://zh.wikipedia.org/wiki/克鲁斯克尔演算法)，使用[并查集]实现

```Python
# Kruskal's algorithm
class Solution:
    def getMinRiskValue(self, N, M, X, Y, W):
        
        # Kruskal's algorithm with union-find
        parent = list(range(N + 1))
        rank = [1] * (N + 1)
        
        def find(x):
            if parent[parent[x]] != parent[x]:
                parent[x] = find(parent[x])
            return parent[x]
        
        def union(x, y):
            px, py = find(x), find(y)
            if px == py:
                return False
            
            if rank[px] > rank[py]:
                parent[py] = px
            elif rank[px] < rank[py]:
                parent[px] = py
            else:
                parent[px] = py
                rank[py] += 1
            
            return True
        
        edges = sorted(zip(W, X, Y))
        
        for w, x, y in edges:
            if union(x, y) and find(0) == find(N): # early return without constructing MST
                return w
```

算法 2: [Prim's algorithm](https://zh.wikipedia.org/wiki/普林姆算法)，使用[优先级队列 (堆)]实现

```python
# Prim's algorithm
class Solution:
    def getMinRiskValue(self, N, M, X, Y, W):
        
        # construct graph
        adj = collections.defaultdict(list)
        for i in range(M):
            adj[X[i]].append((Y[i], W[i]))
            adj[Y[i]].append((X[i], W[i]))
            
        # Prim's algorithm with min heap
        MST = collections.defaultdict(list)
        min_heap = [(w, 0, v) for v, w in adj[0]]
        heapq.heapify(min_heap)
        
        while N not in MST:
            w, p, v = heapq.heappop(min_heap)
            if v not in MST:
                MST[p].append((v, w))
                MST[v].append((p, w))
                for n, w in adj[v]:
                    if n not in MST:
                        heapq.heappush(min_heap, (w, v, n))
                
        # dfs to search route from 0 to n
        dfs = [(0, None, float('-inf'))]
        while dfs:
            v, p, max_w = dfs.pop()
            for n, w in MST[v]:
                cur_max_w = max(max_w, w)
                if n == N:
                    return cur_max_w
                if n != p:
                    dfs.append((n, v, cur_max_w))
```

