# 滑动窗口



## 示例



### ✅[长度最小的子数组 x](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

```python
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        if not nums:
            return 0
        
        n = len(nums)
        ans = n + 1 #在最后return 0情况下防止全部nuns加起来等于s 
        start, end = 0, 0
        total = 0
        while end < n:
            total += nums[end]
            while total >= s:
                ans = min(ans, end - start + 1)
                total -= nums[start]
                start += 1
            end += 1
        
        return 0 if ans == n + 1 else ans
```



### ✅[最小覆盖子串 x](https://leetcode-cn.com/problems/minimum-window-substring/)

```Python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        need = defaultdict(int) # 存储窗口之外还需要的各个char数量

        for i in t:
            need[i] += 1 # 刚开始用t初始化need
        
        min_len, res = float("inf"), ""  # 最小长度， 结果

        counter = len(t) # 一共还需要的数量
        l, r = 0, 0


        while r < len(s):
            if need[s[r]] > 0: # r指向的字符还需要
                counter -= 1
            need[s[r]] -= 1
            r += 1

            while counter == 0:
                if min_len > r - l:
                    min_len = min(min_len, r - l)
                    res = s[l:r]

                if need[s[l]] == 0:
                    counter += 1
                need[s[l]] += 1
                l += 1
        
        return res
```



### ✅[permutation-in-string](https://leetcode-cn.com/problems/permutation-in-string/)

```Python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        
        target = collections.defaultdict(int)
        
        for c in s1:
            target[c] += 1
        
        r, num_char = 0, len(target)

        while r < len(s2):
            if s2[r] in target:
                l, count = r, 0
                window = collections.defaultdict(int)
                while r < len(s2):
                    c = s2[r]
                    if c not in target:
                        break
                    window[c] += 1
                    if window[c] == target[c]:
                        count += 1
                        if count == num_char:
                            return True
                    while window[c] > target[c]:
                        window[s2[l]] -= 1
                        if window[s2[l]] == target[s2[l]] - 1:
                            count -= 1
                        l += 1
                    r += 1
            else:
                r += 1
        
        return False
```



### [✅find-all-anagrams-in-a-string](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

```Python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        
        target = collections.defaultdict(int)
        
        for c in p:
            target[c] += 1
        
        r, num_char = 0, len(target)
        
        results = []
        while r < len(s):
            if s[r] in target:
                l, count = r, 0
                window = collections.defaultdict(int)
                while r < len(s):
                    c = s[r]
                    if c not in target:
                        break
                    window[c] += 1
                    if window[c] == target[c]:
                        count += 1
                        if count == num_char:
                            results.append(l)
                            window[s[l]] -= 1
                            count -= 1
                            l += 1
                    while window[c] > target[c]:
                        window[s[l]] -= 1
                        if window[s[l]] == target[s[l]] - 1:
                            count -= 1
                        l += 1
                    r += 1
            else:
                r += 1
        
        return results
```



### ✅[longest-substring-without-repeating-characters](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```Python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        
        last_idx = {}
        
        l, max_length = 0, 0
        for r, c in enumerate(s):
            if c in last_idx and last_idx[c] >= l:
                max_length = max(max_length, r - l)
                l = last_idx[c] + 1
            last_idx[c] = r
        
        return max(max_length, len(s) - l) # note that the last substring is not judged in the loop
```



## 总结

- 和双指针题目类似，更像双指针的升级版，滑动窗口核心点是维护一个窗口集，根据窗口集来进行处理
- 核心步骤:
  - right 右移
  - 求结果
  - 收缩:left 右移
