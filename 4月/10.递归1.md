# 递归



## 介绍



**参数，终止条件，拆解，返回的值**



## 示例

### ✅[两两交换链表中的节点 x](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```Python
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        
        new_head = head.next
        head.next = self.swapPairs(new_head.next)
        new_head.next = head

        return new_head
```



### ✅[不同的二叉搜索树 II x](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

假设当前序列长度为 n，如果我们枚举根节点的值为 i，那么根据二叉搜索树的性质我们可以知道左子树的节点值的集合为[1…i−1]，右子树的节点值的集合为 [i+1…n]。而左子树和右子树的生成相较于原问题是一个序列长度缩小的子问题；

generateTree_lr(l, n - 1)，generateTree_lr(n + 1, r)获得所有可行的左子树和可行的右子树，那么最后一步我们只要从可行左子树集合中选一棵，再从可行右子树集合中选一棵拼接到根节点上，并将生成的二叉搜索树放入答案数组即可。

```Python
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:
        def generateTree_lr(l, r):
            if l > r: return [None] # 示例输出有None

            result = []
            for n in range(l, r + 1):
                left = generateTree_lr(l, n - 1)
                right = generateTree_lr(n + 1, r)

                for left_tree in left:
                    for right_tree in right:
                        result.append(TreeNode(n, left_tree, right_tree))
            
            return result

        return  generateTree_lr(1, n) if n > 0 else []
```



### ✅[斐波那契数 x](https://leetcode-cn.com/problems/fibonacci-number/)

可以用递归，也可以用动态规划滚动数组

```Python
class Solution:
    def fib(self, n: int) -> int:
        if n < 2: return n
        k = 2
        # base case
        res = [0, 1]
        # 状态转移
        while k <= n:
            res[0], res[1] = res[1], res[0] + res[1]
            k += 1
        return res[1]
```

