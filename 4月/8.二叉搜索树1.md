# 二叉搜索树

## 定义



- 每个节点中的值必须大于（或等于）存储在其左侧子树中的任何值。
- 每个节点中的值必须小于（或等于）存储在其右子树中的任何值。

## 应用



### ✅[验证二叉搜索树 x](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```Python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
      #帮助判定考虑以 root 为根的子树，判断子树中所有节点的值是否都在（l ,r）的范围内（注意是开区间）。如果root.val不在 (l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。
        def helper(node, lower = float('-inf'), upper = float('inf')) -> bool: 
            if not node:
                return True
            
            val = node.val
            if val <= lower or val >= upper:
                return False

            if not helper(node.right, val, upper):
                return False
            if not helper(node.left, lower, val):
                return False
            return True

        return helper(root)
```



### ✅[二叉搜索树中的插入操作 x](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

- 思路：找到最后一个满足插入条件叶子节点即可

```Python
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root:
            return TreeNode(val)
        
        node = root
        while node:
            if val < node.val:
                if not node.left:
                    node.left = TreeNode(val)
                    break
                else:
                    node = node.left
            else:
                if not node.right:
                    node.right = TreeNode(val)
                    break
                else:
                    node = node.right
        return root
```



### ✅[删除二叉搜索树中的节点 x](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

**在二叉搜索树中（Binary Search Tree）中，其子节点构成有如下规律：**

每个节点中的值必须大于（或等于）存储在其左子树中的任何值
每个节点中的值必须小于（或等于）存储在其右子树中的任何值
其中序遍历结果为递增的有序序列



**执行删除操作时，需要根据其子节点情况来分类讨论不同的删除操作：**

1.待删除节点没有子节点：将该节点置空
2.待删除结点只有一个子节点（左节点或右节点）：用其子节点代替
3.待删除节点有左右两个节点：用其前驱节点或后继节点代替

前驱节点：中序遍历的递增序列中对应的前一个节点，其值是小于待删除节点值中的最大值，位于待删除节点左子树中的最靠右的节点
后继节点：中序遍历的递增序列中对应的后一个节点，其值是大于待删除节点值中的最小值，位于待删除节点右子树中的最靠左的节点

```Python
class Solution:
    def getsuccessor(self, root): # 获取root的后继节点
        root = root.right # 定位到root右子树
        while root.left:  # 寻找右子树中最靠左的节点
            root = root.left
        return root

    def getprecursor(self, root): # 获取root的前驱节点
        root = root.left # 定位到root左子树
        while root.right: # 寻找左子树中最靠右的节点
            root = root.right
        return root

    def deleteNode(self, root: TreeNode, key: int) -> TreeNode: # 删除具有key值的节点，并返回删除后的根节点
        if not root: return root
        # 最外层的if...elif...else用于搜索待删除结点
        if key < root.val: # 待删除结点值小于根节点，位于根节点左子树
            root.left = self.deleteNode(root.left, key) # 递归删除左子树，并返回删除后的左子树
        elif root.val < key: # 待删除结点值大于根节点，位于根节点右子树
            root.right = self.deleteNode(root.right, key) # 递归删除右子树，并返回删除后的右子树
        else: # 待删除节点为根节点
            if not root.left and not root.right:  # 对应情况1，待删除结点没有子节点
                root = None
            elif root.left and not root.right: # 对应情况2，待删除节点只有左节点
                root = root.left # 用左节点代替该节点
            elif not root.left and root.right: # 对应情况2，待删除节点只有右节点
                root = root.right # 用右节点代替该节点
            else:  # 对应情况3，待删除节点有左右两个节点
                succ = self.getsuccessor(root) # 找到后继节点
                root.val = succ.val  # 将值替换为后继节点的值
                root.right = self.deleteNode(root.right, succ.val) # 删除没用的后继节点
        return root
```



### ✅[平衡二叉树 x](https://leetcode-cn.com/problems/balanced-binary-tree/)

```Python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def helper(root):
            if not root:
                return 0, True
            leftdepth, leftres = helper(root.left)
            rightdepth, rightres = helper(root.right)

            return 1 + max(leftdepth, rightdepth), leftres and rightres and abs(leftdepth - rightdepth) <= 1
        
        depth, res = helper(root)
        return res
```

