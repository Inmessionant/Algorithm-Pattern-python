# 链表



## 常见题型



### ✅[删除排序链表中的重复元素 x](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

```Python
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next: return head # 如果链表为空或者只有一个元素，直接返回head
        cur = head
        while cur and cur.next: # 当前元素和下一个元素存在才能比较有没有重复，cur到链表最后一个元素时不进入循环
            if cur.val == cur.next.val:
              cur.next = cur.next.next
            else: 
              cur = cur.next

        return head
```



### ✅[删除排序链表中的重复元素 II x](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

```Python
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head or not head.next: # head为空或者链表只有一个元素head
            return head 

        dummy = ListNode(next=head)
        slow = dummy
        fast = head

        while fast:
            while fast.next and fast.val == fast.next.val:
                fast = fast.next
            if slow.next == fast:
                slow = fast
            else:
                slow.next = fast.next

            fast = fast.next

        return dummy.next
```



### ✅[反转链表 x](https://leetcode-cn.com/problems/reverse-linked-list/)

迭代

```Python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        pre = None
        cur = head
        while cur:
            temp = cur.next   # 先把原来cur.next位置存起来
            cur.next = pre
            pre = cur
            cur = temp
        return pre
```

递归

```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        nextNode = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return nextNode
```



### ✅[反转链表 II x](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

- 思路：找到要翻转部分的链表,将其翻转,再与原链表拼接;

```Python
class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        dummy = ListNode(next=head)
        pre = dummy
        # 找到翻转链表部分的前一个节点, 1->2->3->4->5->NULL, m = 2, n = 4 指的是 节点值为1
        for _ in range(m-1):
            pre = pre.next
        # 用双指针,进行链表翻转
        node = None
        cur = pre.next
        for _ in range(n-m+1):
            tmp = cur.next
            cur.next = node
            node = cur
            cur = tmp
        # 将翻转部分 和 原链表拼接
        pre.next.next = cur
        pre.next = node
        return dummy.next
```



### ✅[合并两个有序链表 x](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

- 思路：通过 dummy node 链表，连接各个元素

```Python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode()
        pre = dummy

        while l1 and l2:
            if l1.val < l2.val:
                pre.next = l1
                l1 = l1.next
            else:
                pre.next = l2
                l2 = l2.next
            pre = pre.next

        pre.next = l1 if l1 else l2
        return dummy.next 
```



### ✅[分隔链表 x](https://leetcode-cn.com/problems/partition-list/)



- 思路：只需维护两个链表,将小于 x 的节点，放到一个链表。将大于等于 x 的节点，放到另外一个链表，最后连接这两个链表

```go
class Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        if not head or not head.next:
            return head

        dummy1, dummy2 = ListNode(), ListNode()
        cur1, cur2, cur = dummy1, dummy2, head

        while cur:
            if cur.val < x:
                cur1.next = cur
                cur1 = cur1.next
            else:
                cur2.next = cur
                cur2 = cur2.next
            cur = cur.next
        
        cur1.next = dummy2.next
        cur2.next = None

        return dummy1.next
```



### ✅[排序链表 x](https://leetcode-cn.com/problems/sort-list/)

- 思路：归并排序(自顶向下)，对链表自顶向下归并排序的过程如下:

  1.找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动2 步，慢指针每次移动 1 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点；
2.对两个子链表分别排序。将两个排序后的子链表合并，得到完整的排序后的链表。可以使用「21. 合并两个有序链表」的做法，将两个有序的子链表进行合并。上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于1，即**当链表为空或者链表只包含 1 个节点时，不需要对链表进行拆分和排序**

```Python
class Solution:
    def mergefunc(self, head1, head2):
        dummy = ListNode()
        cur1, cur2, cur = head1, head2, dummy

        while cur1 and cur2:
            if cur1.val < cur2.val:
                cur.next = cur1
                cur1 = cur1.next
            else:
                cur.next = cur2
                cur2 = cur2.next
            cur = cur.next
        
        cur.next = cur1 if cur1 else cur2
        return dummy.next

    def sortList(self, head: ListNode) -> ListNode:
        if not head or not head.next: # termination.
            return head
        
        slow = fast = head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
        # save and cut.
        mid = slow.next
        slow.next = None
		# merge `left` and `right` linked list and return it.
        return self.mergefunc(self.sortList(head), self.sortList(mid))
```



### ✅[重排链表 x](https://leetcode-cn.com/problems/reorder-list/)

- 思路：找到中点断开，翻转后面部分，然后合并前后两个链表.

```Python
class Solution:
    def reorderList(self, head: ListNode) -> None:
        """
        Do not return anything, modify head in-place instead.
        """
        if not head:
            return 
        
        mid = self.midNode(head)
        l1 = head
        l2 = mid.next
        mid.next = None
        l2 = self.reverseList(l2)
        self.mergeList(l1, l2)
    
    def midNode(self, head:ListNode) -> ListNode:
        slow = fast = head
        while fast.next and fast.next.next:
            slow = slow.next
            fast = fast.next.next
        return slow

    def reverseList(self, head:ListNode) -> ListNode:
        pre = None
        cur = head
        while cur:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        return pre

    def mergeList(self, l1:ListNode, l2:ListNode):
        while l1 and l2:
            l1tmp, l2tmp = l1.next, l2.next
            l1.next = l2
            l2.next = l1tmp
            l1 = l1tmp
            l2 = l2tmp
```



### [linked-list-cycle](https://leetcode-cn.com/problems/linked-list-cycle/)

> 给定一个链表，判断链表中是否有环。

- 思路1：Hash Table 记录所有结点判断重复，空间复杂度 O(n) 非最优，时间复杂度 O(n) 但必然需要 n 次循环

  ```python
  class Solution:
      def hasCycle(self, head: ListNode) -> bool:
          seen = set()
          while head:
              if head in seen:
                  return True
              seen.add(head)
              head = head.next
          return False
  ```

  

- 思路2：「Floyd 判圈算法」（又称龟兔赛跑算法）

```Python
class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if not head or not head.next: # 空链表或者只有一个结点
            return False
        
        slow, fast = head, head

        while True:
            if not fast or not fast.next: # 最后为None说明没有环
                return False

            slow = slow.next
            fast = fast.next.next

            if fast == slow:
                return True
                break
```

### ✅[linked-list-cycle-ii](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

- 思路：快慢指针，快慢相遇之后，快指针回到头，快慢指针步调一致一起移动，再次相遇点即为入环点。指针分别走了 nb，2nb 个 **环的周长** ,a（非环部分长度）+b（环部分长度）

```Python
class Solution(object):
    def detectCycle(self, head):
        fast, slow = head, head
        while True:
            if not (fast and fast.next): return
            fast, slow = fast.next.next, slow.next
            if fast == slow: break
        fast = head
        while fast != slow:
            fast, slow = fast.next, slow.next
        return fast
```

### ✅[palindrome-linked-list](https://leetcode-cn.com/problems/palindrome-linked-list/)

- 思路：使用list,使用切片判断是否为回文

```Python
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        vals = list()
        cur = head

        while cur:
            vals.append(cur.val)
            cur = cur.next
        
        return vals == vals[::-1]
```

### [copy-list-with-random-pointer](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

> 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。
> 要求返回这个链表的 深拷贝。

- 思路1：hash table 存储 random 指针的连接关系

```Python
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        
        if head is None:
            return None
        
        parent = collections.defaultdict(list)
        
        out = Node(0)
        o, n = head, out
        while o is not None:
            n.next = Node(o.val)
            n = n.next
            if o.random is not None:
                parent[o.random].append(n)
            o = o.next
            
        o, n = head, out.next
        while o is not None:
            if o in parent:
                for p in parent[o]:
                    p.random = n
            o = o.next
            n = n.next
        
        return out.next
```

- 思路2：复制结点跟在原结点后面，间接维护连接关系，优化空间复杂度，建立好新 list 的 random 链接后分离

```Python
class Solution:
    def copyRandomList(self, head: 'Node') -> 'Node':
        
        if head is None:
            return None
        
        p = head
        while p is not None:
            p.next = Node(p.val, p.next)
            p = p.next.next
        
        p = head
        while p is not None:
            if p.random is not None:
                p.next.random = p.random.next
            p = p.next.next
        
        new = head.next
        o, n = head, new
        while n.next is not None:
            o.next = n.next
            n.next = n.next.next
            o = o.next
            n = n.next
        o.next = None
        
        return new
```



