# 优先级队列 (堆)



用到优先级队列 (priority queue) 或堆 (heap) 的题一般需要维护一个动态更新的池，元素会被频繁加入到池中或从池中被取走，每次取走的元素为池中优先级最高的元素 (可以简单理解为最大或者最小)。**用堆来实现优先级队列是效率非常高的方法，加入或取出都只需要 O(log N) 的复杂度**



`heapq.heappush(heap, item)`

`heapq.heappop(heap)`

`heapq.heappushpop(heap, item)`  将 *item* **放入堆中**，然后**弹出**并返回 *heap* 的最小元素

`heapq.heapify(x)`  将list *x* 转换成堆，原地，线性时间内



`heapq.nlargest(n, iterable, key)`

`heapq.nsmallest(n, iterable, key)`

这两个函数还接受一个key参数，用于dict或其他数据结构类型使用

```python
import heapq
from pprint import pprint
portfolio = [
    {'name': 'IBM', 'shares': 100, 'price': 91.1},
    {'name': 'AAPL', 'shares': 50, 'price': 543.22},
    {'name': 'FB', 'shares': 200, 'price': 21.09},
    {'name': 'HPQ', 'shares': 35, 'price': 31.75},
    {'name': 'YHOO', 'shares': 45, 'price': 16.35},
    {'name': 'ACME', 'shares': 75, 'price': 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
pprint(cheap)
pprint(expensive)

"""
输出：
[{'name': 'YHOO', 'price': 16.35, 'shares': 45},
 {'name': 'FB', 'price': 21.09, 'shares': 200},
 {'name': 'HPQ', 'price': 31.75, 'shares': 35}]
[{'name': 'AAPL', 'price': 543.22, 'shares': 50},
 {'name': 'ACME', 'price': 115.65, 'shares': 75},
 {'name': 'IBM', 'price': 91.1, 'shares': 100}]
"""
```



### ✅[丑数 x](https://leetcode-cn.com/problems/chou-shu-lcof/)

```python
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        factors = [2, 3, 5]
        seen = {1}
        heap = [1]

        for i in range(n - 1):
            curr = heapq.heappop(heap)
            for factor in factors:
                if (nxt := curr * factor) not in seen:  # 海象运算符
                    seen.add(nxt)
                    heapq.heappush(heap, nxt)

        return heapq.heappop(heap)
```





## Kth largest/smallest



### ✅[数据流中的第 K 大元素 x](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/)

```Python
class KthLargest:

    def __init__(self, k: int, nums: List[int]):
        self.K = k
        self.min_heap = []
        for num in nums:
            if len(self.min_heap) < self.K: #miniheap容量小于k，直接用heapq加进去
                heapq.heappush(self.min_heap, num)
            elif num > self.min_heap[0]: #当len(miniheap) = k时候，因为只保留最大k个元素，所以要和miniheap[0]比较，如果比miniheap[0]大，把miniheap[0]弹出来，num加进去（heapq维护的最小堆）
                heapq.heappushpop(self.min_heap, num)

    def add(self, val: int) -> int:
        if len(self.min_heap) < self.K:
            heapq.heappush(self.min_heap, val)
        elif val > self.min_heap[0]:
            heapq.heappushpop(self.min_heap, val)

        return self.min_heap[0]
```



### ✅[有序矩阵中第 K 小的元素 x](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)

```Python
class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        row, col = len(matrix), len(matrix[0])

        heap = []

        for i in range(row):
            for j in range(col):
                if len(heap) < k:
                    heapq.heappush(heap, -matrix[i][j])
                elif -matrix[i][j] > heap[0]:
                    heapq.heappushpop(heap, -matrix[i][j])

        return -heap[0]
```



### ✅[查找和最小的K对数字 x](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)

它仅从矩阵左上角的第一对开始，然后根据需要从那里开始扩展。 每当将一对选择为输出结果时，该行中的下一对就会添加到当前选项的优先队列中。 同样，如果所选对是该行中的第一对，则将下一行中的第一对添加到队列中；

```Python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        
        m, n = len(nums1), len(nums2)
        result = []
        
        if m * n == 0:
            return result
        
        min_heap = [(nums1[0] + nums2[0], 0, 0)]
        seen = set()
        
        while min_heap and len(result) < k:
            _, i1, i2 = heapq.heappop(min_heap)
            result.append([nums1[i1], nums2[i2]])
            if i1 < m - 1 and (i1 + 1, i2) not in seen:
                heapq.heappush(min_heap, (nums1[i1 + 1] + nums2[i2], i1 + 1, i2))
                seen.add((i1 + 1, i2))
            if i2 < n - 1 and (i1, i2 + 1) not in seen:
                heapq.heappush(min_heap, (nums1[i1] + nums2[i2 + 1], i1, i2 + 1))
                seen.add((i1, i2 + 1))
        
        return result
```



## Greedy + Heap



Heap 可以高效地取出或更新当前池中优先级最高的元素，因此适用于一些需要 greedy 算法的场景；



### ✅[最大的团队表现值 x](https://leetcode-cn.com/problems/maximum-performance-of-a-team/)

- [See my review here](https://leetcode-cn.com/problems/maximum-performance-of-a-team/solution/greedy-with-min-heap-lai-zi-zhen-shi-mian-shi-de-j/)

**去掉“最多 K 个工程师”这个条件：**意味着我们可以取任意多的人组成团队。这是这道题的一个简化版本，贪心策略是**按照效率降序排列**后依次检查由前 i 个工程师组成的团队，i 从 1 到 N。为什么这个贪心策略是对的呢？假设在排序后，速度为 [s1, s2, ..., sN]，效率为 [e1, e2, ..., eN]，且有 e1 >= e2 >= ... >= eN。考虑以 ei 为效率最小值的最优团队，这个团队必然由前 i 个工程师组成，因为他们是所有效率 >= ei 的工程师，使得团队的速度和最大为 s1 + s2 + ... + si。贪心策略即是检查每个这样的最优团队以找到全局最优解；

```python
class Solution:
    def maxPerformance(self, n, speed, efficiency):
        
        people = sorted(zip(speed, efficiency), key = lambda x: -x[1])
        result, sumSpeed = 0, 0
        
        for s, e in people:
            sumSpeed += s
            reslut = max(result, sumSpeed * e)
        
        return result
```

**加上“最多 K 个工程师”这个条件：**我们仍然希望检查以 ei 为效率最小值的最优团队，只不过此时我们只能最多取 K 个人，所以这意味着我们要找效率值 >= ei 中速度值最大的 K 个人, 相当于多了一个非常经典的从数组里取最大 K 个元素的子问题，解法也是非常经典的最小堆的一个应用；

```Python
# similar question: LC 857
class Solution:
    def maxPerformance(self, n, speed, efficiency, k):
        
        people = sorted(zip(speed, efficiency), key=lambda x: -x[1])
        
        result, sum_speed = 0, 0
        min_heap = []
		
        for i, (s, e) in enumerate(people):
            if i < k:
                sum_speed += s
                heapq.heappush(min_heap, s)
            elif s > min_heap[0]:
                sum_speed += s - heapq.heappushpop(min_heap, s)
            
            result = max(result, sum_speed * e)
        
        return result % 1000000007
```

### [ipo](https://leetcode-cn.com/problems/ipo/)

- 贪心策略为每次做当前成本范围内利润最大的项目。

```Python
class Solution:
    def findMaximizedCapital(self, k: int, W: int, Profits: List[int], Capital: List[int]) -> int:
        N = len(Profits)
        projects = sorted([(-Profits[i], Capital[i]) for i in range(N)], key=lambda x: x[1])
        
        projects.append((0, float('inf')))
        
        max_profit_heap = []
        
        for i in range(N + 1):
            while projects[i][1] > W and len(max_profit_heap) > 0 and k > 0:
                W -= heapq.heappop(max_profit_heap)
                k -= 1
            
            if projects[i][1] > W or k == 0:
                break
            
            heapq.heappush(max_profit_heap, projects[i][0])

        return W
```

### [meeting-rooms-ii](https://leetcode-cn.com/problems/meeting-rooms-ii/)

- 此题用 greedy + heap 解并不是很 intuitive，存在复杂度相同但更简单直观的做法。

```Python
class Solution:
    def minMeetingRooms(self, intervals: List[List[int]]) -> int:
        
        if len(intervals) == 0: return 0
        
        intervals.sort(key=lambda item: item[0])
        end_times = [intervals[0][1]]
        
        for interval in intervals[1:]:
            if end_times[0] <= interval[0]:
                heapq.heappop(end_times)
            
            heapq.heappush(end_times, interval[1])
        
        return len(end_times)
```

### [reorganize-string](https://leetcode-cn.com/problems/reorganize-string/)

> 给定一个字符串 S，检查是否能重新排布其中的字母，使得任意两相邻的字符不同。若可行，输出任意可行的结果。若不可行，返回空字符串。

- 贪心策略为每次取前两个最多数量的字母加入到结果。

```Python
class Solution:
    def reorganizeString(self, S: str) -> str:
        
        max_dup = (len(S) + 1) // 2
        counts = collections.Counter(S)
        
        heap = []
        for c, f in counts.items():
            if f > max_dup:
                return ''
            heap.append([-f, c])
        heapq.heapify(heap)
        
        result = []
        while len(heap) > 1:
            first = heapq.heappop(heap)
            result.append(first[1])
            first[0] += 1
            second = heapq.heappop(heap)
            result.append(second[1])
            second[0] += 1
            
            if first[0] < 0:
                heapq.heappush(heap, first)
            if second[0] < 0:
                heapq.heappush(heap, second)
        
        if len(heap) == 1:
            result.append(heap[0][1])
        
        return ''.join(result)
```



## **Prim's Algorithm**



实现上是 greedy + heap 的一个应用，用于构造图的最小生成树 (MST)



### [minimum-risk-path](https://www.lintcode.com/problem/minimum-risk-path/description)

```Python
class Solution:
    def getMinRiskValue(self, N, M, X, Y, W):
        
        # construct graph
        adj = collections.defaultdict(list)
        for i in range(M):
            adj[X[i]].append((Y[i], W[i]))
            adj[Y[i]].append((X[i], W[i]))
            
        # Prim's algorithm with min heap
        MST = collections.defaultdict(list)
        min_heap = [(w, 0, v) for v, w in adj[0]]
        heapq.heapify(min_heap)
        
        while N not in MST:
            w, p, v = heapq.heappop(min_heap)
            if v not in MST:
                MST[p].append((v, w))
                MST[v].append((p, w))
                for n, w in adj[v]:
                    if n not in MST:
                        heapq.heappush(min_heap, (w, v, n))
                
        # dfs to search route from 0 to n
        dfs = [(0, None, float('-inf'))]
        while dfs:
            v, p, max_w = dfs.pop()
            for n, w in MST[v]:
                cur_max_w = max(max_w, w)
                if n == N:
                    return cur_max_w
                if n != p:
                    dfs.append((n, v, cur_max_w))
```





## Dijkstra's Algorithm



该算法无法判断是否存在负权环路，如果存在，算法将失效

实现上是 greedy + heap 的一个应用，用于求解图的单源最短路径相关的问题，生成的树为最短路径树 (SPT)



### ✅[网络延迟时间 x](https://leetcode-cn.com/problems/network-delay-time/)

- 标准的单源最短路径问题，使用朴素的的 Dijikstra 算法即可，可以当成模板使用；x

```Python
class Solution:
    def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:
        
        # construct graph
        graph_neighbors = collections.defaultdict(list)
        for s, e, t in times:
            graph_neighbors[s].append((e, t))
        
        SPT = {}
        mini_heap = [(0, K)]

        # Dijkstra
        while mini_heap:
            delay, node = heapq.heappop(mini_heap)
            if node not in SPT:
                SPT[node] = delay
                for n, d in graph_neighbors[node]:
                    if n not in SPT:
                        heapq.heappush(mini_heap, (d + delay, n))

        return max(SPT.values()) if len(SPT) == N else -1
```



### [cheapest-flights-within-k-stops](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)

- 在标准的单源最短路径问题上限制了路径的边数，因此需要同时维护当前 SPT 内每个结点最短路径的边数，当遇到边数更小的路径 (边权和可以更大) 时结点需要重新入堆，以更新后继在边数上限内没达到的结点。

```Python
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        
        # construct graph
        graph_neighbor = collections.defaultdict(list)
        for s, e, p in flights:
            graph_neighbor[s].append((e, p))
        
        # modified Dijkstra
        prices, steps = {}, {}
        min_heap = [(0, 0, src)]
        
        while len(min_heap) > 0:
            price, step, node = heapq.heappop(min_heap)
            
            if node == dst: # early return
                return price

            if node not in prices:
                prices[node] = price
            
            steps[node] = step
            if step <= K:
                step += 1
                for n, p in graph_neighbor[node]:
                    if n not in prices or step < steps[n]:
                        heapq.heappush(min_heap, (p + price, step, n))
        
        return -1
```



