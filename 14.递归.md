# 递归



## 介绍



**参数，终止条件，拆解，返回的值**



## 示例

### [swap-nodes-in-pairs](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)


**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。

```Python
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        
        if head is not None and head.next is not None:
            head_next_pair = self.swapPairs(head.next.next)
            p = head.next
            head.next = head_next_pair
            p.next = head
            head = p
        
        return head
```



### [unique-binary-search-trees-ii](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)



注意：此题用来训练递归思维有理论意义，但是实际上算法返回的树并不是 deep copy，多个树之间会共享子树。

```Python
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:
        
        def generateTrees_rec(i, j):
            
            if i > j:
                return [None]
            
            result = []
            for m in range(i, j + 1):
                left = generateTrees_rec(i, m - 1)
                right = generateTrees_rec(m + 1, j)
                
                for l in left:
                    for r in right:
                        result.append(TreeNode(m, l, r))
            
            return result
        
        return generateTrees_rec(1, n) if n > 0 else []
```



### ✅[斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

可以用递归，也可以用动态规划滚动数组

```Python
class Solution:
    def fib(self, n: int) -> int:
        if n < 2: return n
        k = 2
        # base case
        res = [0, 1]
        # 状态转移
        while k <= n:
            res[0], res[1] = res[1], res[0] + res[1]
            k += 1
        return res[1]
```

