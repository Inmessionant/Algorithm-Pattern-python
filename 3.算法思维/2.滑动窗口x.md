# 滑动窗口



## 示例



### ✅[长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)



```python
class Solution:
    def minSubArrayLen(self, s: int, nums: List[int]) -> int:
        if not nums:
            return 0
        
        n = len(nums)
        ans = n + 1 #在最后return 0情况下防止全部nuns加起来等于s 
        start, end = 0, 0
        total = 0
        while end < n:
            total += nums[end]
            while total >= s:
                ans = min(ans, end - start + 1)
                total -= nums[start]
                start += 1
            end += 1
        
        return 0 if ans == n + 1 else ans
```



### [定长子串中元音的最大数目](https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)



```

```



### [minimum-window-substring](https://leetcode-cn.com/problems/minimum-window-substring/)



```Python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        
        target = collections.defaultdict(int)
        window = collections.defaultdict(int)
        
        for c in t:
            target[c] += 1
            
        min_size = len(s) + 1
        min_str = ''
        
        l, r, count, num_char = 0, 0, 0, len(target)
        
        while r < len(s):
            c = s[r]
            r += 1

            if c in target:
                window[c] += 1
                
                if window[c] == target[c]:
                    count += 1
                    
                    if count == num_char:
                        while l < r and count == num_char:
                            c = s[l]
                            l += 1
                            
                            if c in target:
                                window[c] -= 1
                                
                                if window[c] == target[c] - 1:
                                    count -= 1
                                    
                        if min_size > r - l + 1:
                            min_size = r - l + 1
                            min_str = s[l - 1:r]
        
        return min_str
```



### [permutation-in-string](https://leetcode-cn.com/problems/permutation-in-string/)



```Python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        
        target = collections.defaultdict(int)
        
        for c in s1:
            target[c] += 1
        
        r, num_char = 0, len(target)

        while r < len(s2):
            if s2[r] in target:
                l, count = r, 0
                window = collections.defaultdict(int)
                while r < len(s2):
                    c = s2[r]
                    if c not in target:
                        break
                    window[c] += 1
                    if window[c] == target[c]:
                        count += 1
                        if count == num_char:
                            return True
                    while window[c] > target[c]:
                        window[s2[l]] -= 1
                        if window[s2[l]] == target[s2[l]] - 1:
                            count -= 1
                        l += 1
                    r += 1
            else:
                r += 1
        
        return False
```



### [find-all-anagrams-in-a-string](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)



```Python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        
        target = collections.defaultdict(int)
        
        for c in p:
            target[c] += 1
        
        r, num_char = 0, len(target)
        
        results = []
        while r < len(s):
            if s[r] in target:
                l, count = r, 0
                window = collections.defaultdict(int)
                while r < len(s):
                    c = s[r]
                    if c not in target:
                        break
                    window[c] += 1
                    if window[c] == target[c]:
                        count += 1
                        if count == num_char:
                            results.append(l)
                            window[s[l]] -= 1
                            count -= 1
                            l += 1
                    while window[c] > target[c]:
                        window[s[l]] -= 1
                        if window[s[l]] == target[s[l]] - 1:
                            count -= 1
                        l += 1
                    r += 1
            else:
                r += 1
        
        return results
```



### [longest-substring-without-repeating-characters](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)



```Python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        
        last_idx = {}
        
        l, max_length = 0, 0
        for r, c in enumerate(s):
            if c in last_idx and last_idx[c] >= l:
                max_length = max(max_length, r - l)
                l = last_idx[c] + 1
            last_idx[c] = r
        
        return max(max_length, len(s) - l) # note that the last substring is not judged in the loop
```



## 总结

- 和双指针题目类似，更像双指针的升级版，滑动窗口核心点是维护一个窗口集，根据窗口集来进行处理
- 核心步骤
  - right 右移
  - 收缩
  - left 右移
  - 求结果
