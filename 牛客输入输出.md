

## 牛客网

牛客网推荐使用sys.stdin.readline()形式输入，输出用print()

```python
'''
输入:
2 3 分别赋给n, m并且转换为int类型
'''
import sys

n, m = map(int, sys.stdin.readline().strip().split())
print(type(n))
print('n', n)
print('n', m)
```



## 赛码网

赛码网建议使用input()输入，输出用print()

```python
'''
输入：
5
(1,2)(5,3)(4,6)(7,5)(9,0)
output:
(4 6)(7 5)(9 0)
'''


nums = int(input())
points = []
for i in range(0, nums):
    read_list = list(map(int, input().split()))
    # read_list = [int(i) for i in input().split()]
    points.append((read_list[0], read_list[1]))
...

for i in points:
    print(i[0], i[1])
```



**输出要注意，按行遍历输出，而不是输出一个list或者tuple**



### 输入一个数字

n为int数字

```python
n = int(input())
```



### 读取一行多个数字(空格分开)

line为list数组

```python
line = list(map(int, input().split(' ')))
```



### 第一个输入n给定行数，接下来每行有m个数据(用空格分开)

res为`n x m` 矩阵

```python
res = []
n = int(input())
for _ in range(n):
    # line = [x for x in input().split(' ')]  # str
    line = [int(x) for x in input().split(' ')]  # int
    res.append(line)
```



### 第一个输入n给定行数，接下来每行输入一个数据

res为list数组

```python
res = []
n = int(input())
for _ in range(n):
    line = [x for x in input().split()]  # str
    line = [int(x) for x in input().split()]  # int
    res.extend(line)
```

```python
4
123
qwe
sd
xcxvdxf
['123', 'qwe', 'sd', 'xcxvdxf']
```



### 多行输入，行数未知:按下换行键然后Ctrl+d结束

res为list数组

```python
import sys 
for line in sys.stdin:
    a = line.split()
    print(int(a[0]) + int(a[1]))
```



### 第一行读取两个数字m,n表示接下来m行xxx和n行xxx

```python
line = list(map(int, input().split(' ')))
mres = []
nres = []
for _ in range(line[0]):
    mres.append(input().split(' '))
for _ in range(line[1]):
    nres.append(input().split(' '))
```



### 输出

```python
res = []
for re in res:
    print(re)  # 多行输出
    print(re, end=' ')  # 输出在一行，用空格分开
```



## main示例

```python
from typing import List

class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def dfs(nums, size, depth, path, used, res):
            if depth == size:
                res.append(path)
                return

            for i in range(size):
                if not used[i]:
                    used[i] = True
                    path.append(nums[i])

                    dfs(nums, size, depth + 1, path, used, res)

                    used[i] = False
                    path.pop()

        size = len(nums)
        if len(nums) == 0:
            return []

        used = [False for _ in range(size)]
        res = []
        dfs(nums, size, 0, [], used, res)
        return res


if __name__ == "__main__":
    nums = [1, 2, 3]
    solution = Solution()
    res = solution.permute(nums)
    print(res)

```

