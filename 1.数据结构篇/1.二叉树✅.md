

## 二叉树



### 二叉树遍历

**前序遍历**：**先访问根节点**，再前序遍历左子树，再前序遍历右子树
**中序遍历**：先中序遍历左子树，**再访问根节点**，再中序遍历右子树
**后序遍历**：先后序遍历左子树，再后序遍历右子树，**再访问根节点**



- 以根访问顺序决定是什么遍历
- 左子树都是优先右子树



#### ✅递归遍历

- 递归实现二叉树遍历非常简单，不同顺序区别仅在于访问父结点顺序 

```python
# 前序遍历
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def preorder(root: TreeNode):
            if not root:
                return
            res.append(root.val)
            preorder(root.left)
            preorder(root.right)
        
        res = list()
        preorder(root)
        return res

# 中序遍历
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        def inorder(root: TreeNode):
          if not root:
            return 
          inorder(root.left)
          res.append(root.val)
          inorder(root.right)
          
        res = list()
        inorder(root)
        return res

# 后序遍历
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        def postorder(root:TreeNode):
            if not root:
                return
            postorder(root.left)
            postorder(root.right)
            res.append(root.val)
        
        res = list()
        postorder(root)
        return res 
```



#### ✅[迭代前序遍历 144](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

对 **中** 进行栈操作，作为标记.  	**中 - 左 - 右 **

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = list()
        while not root:
            return res
        
        node = root
        stack = []

        while node or stack:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.left # 到叶子结点时候为None，跳出循环
            
            node = stack.pop() # 上一个node
            node = node.right
        
        return res
```



#### ✅[迭代中序遍历 94](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

对 **中** 进行栈操作，作为标记（先用指针找到每颗子树的最左下角，然后进行进出栈操作）. **左 -  中 - 右**

```Python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]: 
        
        res = list()

        while not root:
            return res

        node = root
        stack = []

        while node or stack:
            while node:
                stack.append(node)
                node = node.left # # 到叶子结点时候为None，跳出循环
            
            node = stack.pop()
            res.append(node.val)
            node = node.right

        return res
```



#### ✅[迭代后序遍历 145](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

前序遍历是 **中 - 左 - 右**，后序遍历是**左 - 右 - 中** ，将前序遍历的左右调换位置可以得到中右左，反过来打印就是左右中。

```Python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = list()
        while not root:
            return res
        
        node = root
        stack = []

        while node or stack:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.right
            
            node = stack.pop()
            node = node.left
        
        return res[::-1]
        
```



#### ✅分治遍历

分治法应用：先分别处理局部，再合并

- 递归返回条件

- 分段处理

- 合并结果

```Python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        
        if not root:
            return []
        
        left_result = self.preorderTraversal(root.left)
        right_result = self.preorderTraversal(root.right)
        
        return [root.val] + left_result + right_result
```

适用场景：快速排序， 归并排序，二叉树



#### ✅[层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

BFS使用队列，把每个还没有搜索到的点依次放入队列，然后再弹出队列的头部元素当做当前遍历点。如果要**确定当前遍历到了哪一层**，增加了level表示当前遍历到二叉树中的哪一层了，size表示在当前遍历层有多少个元素，也就是队列中的元素数，我们把这些元素一次性遍历完，即把当前层的所有元素都向外走了一步。二叉树的层次遍历，所以同一层的节点应该放在一起。使用队列保存每层的所有节点，每次把队列里的原先所有节点进行出队列操作，再把每个元素的非空左右子节点进入队列。因此即可得到每层的遍历。

```python
#模版（确定在哪一层）
level = 0 #记录层数
while queue 不空：
    size = queue.size()
    while (size --) {
        cur = queue.pop()
        for 节点 in cur的所有相邻节点：
            if 该节点有效且未被访问过：
                queue.push(该节点)
    }
    level ++;
```

​    

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root: return []  # 特殊情况，root为空直接返回
        # 下面就是BFS模板内容，BFS关键在于队列的使用
        queue = deque()
        queue.append(root)  # 压入初始节点
        res = []  # 结果集
        while queue:
            size = len(queue)
            level = []  # 临时变量，记录当前层的节点
            for _ in range(size):  # 遍历某一层的节点
                node = queue.popleft()  # 将要处理的节点弹出
                level.append(node.val)
                if node.left:  # 如果当前节点有左右节点，则压入队列，根据题意注意压入顺序，先左后右，
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)  # 某一层的节点都处理完之后，将当前层的结果压入结果集
        return res
```





## 常见题目示例

###  ✅[maximum-depth-of-binary-tree](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

> 给定一个二叉树，找出其最大深度

- 思路 1：分治遍历

```Python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        
        if root is None:
            return 0
        
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```

- 思路 2：层次遍历

```Python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        queue = collections.deque([root])
        depth = 0

        while queue:
            size =  len(queue) #  当前层元素个数
            depth += 1
            for _ in range(size):
                node = queue.popleft()
                if node.left:
                     queue.append(node.left)
                if node.right: 
                    queue.append(node.right)
        return depth
```

### ✅[balanced-binary-tree](https://leetcode-cn.com/problems/balanced-binary-tree/)

> 给定一个二叉树，判断它是否是高度平衡的二叉树。

- 思路 1：分治法，左边平衡 && 右边平衡 && 左右两边高度 <= 1，

```Python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        def depth(root):
            if not root:
                return 0, True
            depthleft, boolleft = depth(root.left)
            depthright, boolright = depth(root.right)
            
            return max(depthleft, depthright)+1, boolleft and boolright and abs(depthleft - depthright) < 2
        #函数入口，分治遍历
        treedepth, result = depth(root)
        return result
```

### ✅[binary-tree-maximum-path-sum](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

> 给定一个**非空**二叉树，返回其最大路径和。
>
> 
>
> 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
>
> 路径和 是路径中各节点值的总和。
>
> 

- 思路：分治法。最大路径的可能情况：左子树的最大路径，右子树的最大路径，或通过根结点的最大路径。其中通过根结点的最大路径值等于以左子树根结点为端点的最大路径值加以右子树根结点为端点的最大路径值再加上根结点值，这里还要考虑有负值的情况即负值路径需要丢弃不取。

```Python

class Solution:
    def __init__(self):
        self.maxSum = float("-inf") # 求最大值，所以初始化为负无穷,maxSum维护最大路径和，

    def maxPathSum(self, root: TreeNode) -> int:
        def maxGain(node): # 返回以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。
            if not node:
                return 0

            # 递归计算左右子节点的最大贡献值
            # 只有在最大贡献值大于 0 时，才会选取对应子节点
            leftGain = max(maxGain(node.left), 0)
            rightGain = max(maxGain(node.right), 0)
            
            # 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
            priceNewpath = node.val + leftGain + rightGain # node.val<0,maxSum维护的最大路径不变，其他情况下更新maxSum
            
            # 更新答案
            self.maxSum = max(self.maxSum, priceNewpath)
        
            # 返回节点的最大贡献值
            return node.val + max(leftGain, rightGain)
   
        maxGain(root)
        return self.maxSum

```

### ✅[lowest-common-ancestor-of-a-binary-tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

- 思路：分治法，有左子树的公共祖先或者有右子树的公共祖先，就返回子树的祖先，否则返回根节点

```Python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q: # q,p 其中一个是root
            return root
        left = self.lowestCommonAncestor(root.left, p ,q)
        right = self.lowestCommonAncestor(root.right, p ,q)

        # 左边为空，则q,p最近公公祖先在右侧（递归）
        if not left: return right
        if not right:return left
        # 异侧
        return root
```

### ✅[binary-tree-zigzag-level-order-traversal](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

> 给定一个二叉树，返回其节点值的锯齿形层次遍历。Z 字形遍历

- 思路：在BFS迭代模板上改用双端队列控制输出顺序。

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        # 特殊情况处理
        if not root:
            return []        
        # queue 队列先存入根节点
        queue = deque()
        queue.append(root)
        
        # 用来标记当前层是偶数层还是奇数层
        is_even_level = True
        # 结果列表
        ans = []
        
        # 队列不为空时，开始进行遍历
        while queue:
            # 声明双端队列 level_queue
            level_queue = deque()
            # 先计算 queue 的长度 size
            size = len(queue)
            
            # 取出 size 个元素
            for _ in range(size):
                # 取出节点
                node = queue.popleft()
                # 偶数层，将节点值插入到 level_queue 尾部
                if is_even_level:
                    level_queue.append(node.val)
                # 奇数层，将节点值插入到 level_queue 头部
                else:
                    level_queue.appendleft(node.val)
                # 将下一层的节点存放到 queue 中
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            # 这里注意，将双端队列转换为列表的形式，存入结果列表中
            ans.append(list(level_queue))
            # 维护更新 is_even_level
            is_even_level = not is_even_level
        
        return ans

```



### ✅[validate-binary-search-tree](https://leetcode-cn.com/problems/validate-binary-search-tree/)

> 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
>
> 假设一个二叉搜索树具有如下特征：
>
> - 节点的左子树只包含**小于**当前节点的数。
> - 节点的右子树只包含**大于**当前节点的数。
> - 所有左子树和右子树自身必须也是二叉搜索树。

- 分治: **如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。**

```Python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
      #帮助判定考虑以 root 为根的子树，判断子树中所有节点的值是否都在（l ,r）的范围内（注意是开区间）。如果root.val不在 (l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。
        def helper(node, lower = float('-inf'), upper = float('inf')) -> bool: 
            if not node:
                return True
            
            val = node.val
            if val <= lower or val >= upper:
                return False

            if not helper(node.right, val, upper):
                return False
            if not helper(node.left, lower, val):
                return False
            return True

        return helper(root)
```

### ✅[insert-into-a-binary-search-tree](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

> 给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。

- 思路：如果只是为了完成任务则找到最后一个叶子节点满足插入条件即可。但此题深挖可以涉及到如何插入并维持平衡二叉搜索树的问题，并不适合初学者。

```Python
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root: # 树为空，把val建立结点返回
            return TreeNode(val)
        
        pos = root
        while pos:
            if val < pos.val:
                if not pos.left:
                    pos.left = TreeNode(val)
                    break
                else:
                    pos = pos.left
            else:
                if not pos.right:
                    pos.right = TreeNode(val)
                    break
                else:
                    pos = pos.right
        
        return root
```
