## äºŒå‰æ ‘



### äºŒå‰æ ‘éå†

**å‰åºéå†**ï¼š**å…ˆè®¿é—®æ ¹èŠ‚ç‚¹**ï¼Œå†å‰åºéå†å·¦å­æ ‘ï¼Œå†å‰åºéå†å³å­æ ‘
**ä¸­åºéå†**ï¼šå…ˆä¸­åºéå†å·¦å­æ ‘ï¼Œ**å†è®¿é—®æ ¹èŠ‚ç‚¹**ï¼Œå†ä¸­åºéå†å³å­æ ‘
**ååºéå†**ï¼šå…ˆååºéå†å·¦å­æ ‘ï¼Œå†ååºéå†å³å­æ ‘ï¼Œ**å†è®¿é—®æ ¹èŠ‚ç‚¹**



- ä»¥æ ¹è®¿é—®é¡ºåºå†³å®šæ˜¯ä»€ä¹ˆéå†
- å·¦å­æ ‘éƒ½æ˜¯ä¼˜å…ˆå³å­æ ‘



#### ğŸ”¥é€šç”¨é€’å½’éå†

- é€’å½’å®ç°äºŒå‰æ ‘éå†éå¸¸ç®€å•ï¼Œä¸åŒé¡ºåºåŒºåˆ«ä»…åœ¨äºè®¿é—®çˆ¶ç»“ç‚¹é¡ºåº 

```python
# å‰åºéå†
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        def preorder(root: TreeNode):
            if not root:
                return
            res.append(root.val)
            preorder(root.left)
            preorder(root.right)
        
        res = list()
        preorder(root)
        return res

# ä¸­åºéå†
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        def inorder(root: TreeNode):
          if not root:
            return 
          inorder(root.left)
          res.append(root.val)
          inorder(root.right)
          
        res = list()
        inorder(root)
        return res

# ååºéå†
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        def postorder(root:TreeNode):
            if not root:
                return
            postorder(root.left)
            postorder(root.right)
            res.append(root.val)
        
        res = list()
        postorder(root)
        return res 
```



#### ğŸ”¥é¢œè‰²æ ‡è®°æ³•éå†ï¼ˆé€šç”¨ï¼‰

ä½¿ç”¨é¢œè‰²æ ‡è®°èŠ‚ç‚¹çš„çŠ¶æ€ï¼Œæ–°èŠ‚ç‚¹ä¸ºç™½è‰²ï¼Œå·²è®¿é—®çš„èŠ‚ç‚¹ä¸ºç°è‰²ã€‚
å¦‚æœé‡åˆ°çš„èŠ‚ç‚¹ä¸ºç™½è‰²ï¼Œåˆ™å°†å…¶æ ‡è®°ä¸ºç°è‰²ï¼Œç„¶åå°†å…¶å³å­èŠ‚ç‚¹ã€è‡ªèº«ã€å·¦å­èŠ‚ç‚¹ä¾æ¬¡å…¥æ ˆã€‚
å¦‚æœé‡åˆ°çš„èŠ‚ç‚¹ä¸ºç°è‰²ï¼Œåˆ™å°†èŠ‚ç‚¹çš„å€¼è¾“å‡ºã€‚

å¦‚è¦å®ç°å‰åºã€ååºéå†ï¼Œåªéœ€è¦è°ƒæ•´å·¦å³å­èŠ‚ç‚¹çš„å…¥æ ˆé¡ºåºå³å¯ã€‚

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        
        stack = [(root, False)]
        while stack:
            node, color = stack.pop()
            if not node: continue
            if not color: # å…¥æ ˆçš„é¡ºåºå’Œæƒ³è¦éå†çš„é¡ºåºç›¸å,è¿™ä¸ªæ˜¯å‰åºéå†
                stack.append((node.right, False))
                stack.append((node.left, False))
                stack.append((node, True))
            else:
                res.append(node.val)
        return res
```



#### ğŸ”¥[è¿­ä»£å‰åºéå†](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

å¯¹ **ä¸­** è¿›è¡Œæ ˆæ“ä½œï¼Œä½œä¸ºæ ‡è®°

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = list()
        while not root:
            return res
        
        node = root
        stack = []

        while node or stack:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.left
            
            node = stack.pop()
            node = node.right
        
        return res
```



#### ğŸ”¥[è¿­ä»£ä¸­åºéå†](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

å¯¹ **ä¸­** è¿›è¡Œæ ˆæ“ä½œï¼Œä½œä¸ºæ ‡è®°ï¼ˆå…ˆç”¨æŒ‡é’ˆæ‰¾åˆ°æ¯é¢—å­æ ‘çš„æœ€å·¦ä¸‹è§’ï¼Œç„¶åè¿›è¡Œè¿›å‡ºæ ˆæ“ä½œï¼‰

```Python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]: 
        
        res = list()

        while not root:
            return res

        node = root
        stack = []

        while node or stack:
            while node:
                stack.append(node)
                node = node.left
            
            node = stack.pop()
            res.append(node.val)
            node = node.right

        return res
```



#### ğŸ”¥[è¿­ä»£ååºéå†](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

å‰åºéå†æ˜¯ **ä¸­ - å·¦ - å³**ï¼Œååºéå†æ˜¯**å·¦ - å³ - ä¸­** ï¼Œå°†å‰åºéå†çš„å·¦å³è°ƒæ¢ä½ç½®å¯ä»¥å¾—åˆ°ä¸­å³å·¦ï¼Œåè¿‡æ¥æ‰“å°å°±æ˜¯å·¦å³ä¸­ã€‚

```Python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        
        res = list()
        while not root:
            return res
        
        node = root
        stack = []

        while node or stack:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.right
            
            node = stack.pop()
            node = node.left
        
        return res[::-1]
        
```



#### ğŸ”¥åˆ†æ²»éå†ï¼ˆé€šç”¨ï¼‰

```Python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        
        if not root:
            return []
        
        left_result = self.preorderTraversal(root.left)
        right_result = self.preorderTraversal(root.right)
        
        return [root.val] + left_result + right_result
```



åˆ†æ²»æ³•åº”ç”¨ï¼šå…ˆåˆ†åˆ«å¤„ç†å±€éƒ¨ï¼Œå†åˆå¹¶ç»“æœ

é€‚ç”¨åœºæ™¯

- å¿«é€Ÿæ’åº
- å½’å¹¶æ’åº
- äºŒå‰æ ‘

åˆ†æ²»æ³•æ¨¡æ¿

- é€’å½’è¿”å›æ¡ä»¶

- åˆ†æ®µå¤„ç†

- åˆå¹¶ç»“æœ

  

#### ğŸ”¥[å±‚æ¬¡éå†](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

BFSä½¿ç”¨é˜Ÿåˆ—ï¼ŒæŠŠæ¯ä¸ªè¿˜æ²¡æœ‰æœç´¢åˆ°çš„ç‚¹ä¾æ¬¡æ”¾å…¥é˜Ÿåˆ—ï¼Œç„¶åå†å¼¹å‡ºé˜Ÿåˆ—çš„å¤´éƒ¨å…ƒç´ å½“åšå½“å‰éå†ç‚¹ã€‚å¦‚æœè¦**ç¡®å®šå½“å‰éå†åˆ°äº†å“ªä¸€å±‚**ï¼Œå¢åŠ äº†levelè¡¨ç¤ºå½“å‰éå†åˆ°äºŒå‰æ ‘ä¸­çš„å“ªä¸€å±‚äº†ï¼Œsizeè¡¨ç¤ºåœ¨å½“å‰éå†å±‚æœ‰å¤šå°‘ä¸ªå…ƒç´ ï¼Œä¹Ÿå°±æ˜¯é˜Ÿåˆ—ä¸­çš„å…ƒç´ æ•°ï¼Œæˆ‘ä»¬æŠŠè¿™äº›å…ƒç´ ä¸€æ¬¡æ€§éå†å®Œï¼Œå³æŠŠå½“å‰å±‚çš„æ‰€æœ‰å…ƒç´ éƒ½å‘å¤–èµ°äº†ä¸€æ­¥ã€‚äºŒå‰æ ‘çš„å±‚æ¬¡éå†ï¼Œæ‰€ä»¥åŒä¸€å±‚çš„èŠ‚ç‚¹åº”è¯¥æ”¾åœ¨ä¸€èµ·ã€‚ä½¿ç”¨é˜Ÿåˆ—ä¿å­˜æ¯å±‚çš„æ‰€æœ‰èŠ‚ç‚¹ï¼Œæ¯æ¬¡æŠŠé˜Ÿåˆ—é‡Œçš„åŸå…ˆæ‰€æœ‰èŠ‚ç‚¹è¿›è¡Œå‡ºé˜Ÿåˆ—æ“ä½œï¼Œå†æŠŠæ¯ä¸ªå…ƒç´ çš„éç©ºå·¦å³å­èŠ‚ç‚¹è¿›å…¥é˜Ÿåˆ—ã€‚å› æ­¤å³å¯å¾—åˆ°æ¯å±‚çš„éå†ã€‚

```python
#æ¨¡ç‰ˆï¼ˆç¡®å®šåœ¨å“ªä¸€å±‚ï¼‰
level = 0
while queue ä¸ç©ºï¼š
    size = queue.size()
    while (size --) {
        cur = queue.pop()
        for èŠ‚ç‚¹ in curçš„æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹ï¼š
            if è¯¥èŠ‚ç‚¹æœ‰æ•ˆä¸”æœªè¢«è®¿é—®è¿‡ï¼š
                queue.push(è¯¥èŠ‚ç‚¹)
    }
    level ++;
```

â€‹    

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        
        queue = collections.deque()
        queue.append(root) #åˆ›å»ºé˜Ÿåˆ—

        res = list() #ä¿å­˜ç»“æœ

        while queue:
            size = len(queue)	#å½“å‰å±‚çš„å…ƒç´ æ•°
            level = []	#ä¿å­˜å½“å‰å±‚çš„å…ƒç´ 

            for _ in range(size):
                node = queue.popleft() #ä»å·¦è¾¹å¼¹å‡ºquequeçš„node
                if not node:
                    continue
                level.append(node.val)
                queue.append(node.left)
                queue.append(node.right)
            if level: #æŠŠå½“å‰å±‚å…ƒç´ éå†å®Œä¹‹åï¼Œä¿å­˜å½“å‰å±‚å…ƒç´ åˆ°res
                res.append(level)
    
        return res
```



## å¸¸è§é¢˜ç›®ç¤ºä¾‹

### [maximum-depth-of-binary-tree](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å¤§æ·±åº¦ã€‚

- æ€è·¯ 1ï¼šåˆ†æ²»æ³•

```Python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        
        if root is None:
            return 0
        
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
```

- æ€è·¯ 2ï¼šå±‚åºéå†

```Python
class Solution:
    def maxDepth(self, root: TreeNode) -> List[List[int]]:
        
        depth = 0
        if root is None:
            return depth
        
        bfs = collections.deque([root])
        
        while len(bfs) > 0:
            depth += 1
            level_size = len(bfs)
            for _ in range(level_size):
                node = bfs.popleft()
                if node.left is not None:
                    bfs.append(node.left)
                if node.right is not None:
                    bfs.append(node.right)
        
        return depth
```

### [balanced-binary-tree](https://leetcode-cn.com/problems/balanced-binary-tree/)

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯é«˜åº¦å¹³è¡¡çš„äºŒå‰æ ‘ã€‚

- æ€è·¯ 1ï¼šåˆ†æ²»æ³•ï¼Œå·¦è¾¹å¹³è¡¡ && å³è¾¹å¹³è¡¡ && å·¦å³ä¸¤è¾¹é«˜åº¦ <= 1ï¼Œ

```Python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
 
        def depth(root):
            
            if root is None:
                return 0, True
            
            dl, bl = depth(root.left)
            dr, br = depth(root.right)
            
            return max(dl, dr) + 1, bl and br and abs(dl - dr) < 2
        
        _, out = depth(root)
        
        return out
```

- æ€è·¯ 2ï¼šä½¿ç”¨ååºéå†å®ç°åˆ†æ²»æ³•çš„è¿­ä»£ç‰ˆæœ¬

```Python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:

        s = [[TreeNode(), -1, -1]]
        node, last = root, None
        while len(s) > 1 or node is not None:
            if node is not None:
                s.append([node, -1, -1])
                node = node.left
                if node is None:
                    s[-1][1] = 0
            else:
                peek = s[-1][0]
                if peek.right is not None and last != peek.right:
                    node = peek.right
                else:
                    if peek.right is None:
                        s[-1][2] = 0
                    last, dl, dr = s.pop()
                    if abs(dl - dr) > 1:
                        return False
                    d = max(dl, dr) + 1
                    if s[-1][1] == -1:
                        s[-1][1] = d
                    else:
                        s[-1][2] = d
        
        return True
```

### [binary-tree-maximum-path-sum](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

> ç»™å®šä¸€ä¸ª**éç©º**äºŒå‰æ ‘ï¼Œè¿”å›å…¶æœ€å¤§è·¯å¾„å’Œã€‚

- æ€è·¯ï¼šåˆ†æ²»æ³•ã€‚æœ€å¤§è·¯å¾„çš„å¯èƒ½æƒ…å†µï¼šå·¦å­æ ‘çš„æœ€å¤§è·¯å¾„ï¼Œå³å­æ ‘çš„æœ€å¤§è·¯å¾„ï¼Œæˆ–é€šè¿‡æ ¹ç»“ç‚¹çš„æœ€å¤§è·¯å¾„ã€‚å…¶ä¸­é€šè¿‡æ ¹ç»“ç‚¹çš„æœ€å¤§è·¯å¾„å€¼ç­‰äºä»¥å·¦å­æ ‘æ ¹ç»“ç‚¹ä¸ºç«¯ç‚¹çš„æœ€å¤§è·¯å¾„å€¼åŠ ä»¥å³å­æ ‘æ ¹ç»“ç‚¹ä¸ºç«¯ç‚¹çš„æœ€å¤§è·¯å¾„å€¼å†åŠ ä¸Šæ ¹ç»“ç‚¹å€¼ï¼Œè¿™é‡Œè¿˜è¦è€ƒè™‘æœ‰è´Ÿå€¼çš„æƒ…å†µå³è´Ÿå€¼è·¯å¾„éœ€è¦ä¸¢å¼ƒä¸å–ã€‚

```Python
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        
        self.maxPath = float('-inf')
        
        def largest_path_ends_at(node):
            if node is None:
                return float('-inf')
            
            e_l = largest_path_ends_at(node.left)
            e_r = largest_path_ends_at(node.right)
            
            self.maxPath = max(self.maxPath, node.val + max(0, e_l) + max(0, e_r), e_l, e_r)
            
            return node.val + max(e_l, e_r, 0)
        
        largest_path_ends_at(root)
        return self.maxPath
```

### [lowest-common-ancestor-of-a-binary-tree](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚

- æ€è·¯ï¼šåˆ†æ²»æ³•ï¼Œæœ‰å·¦å­æ ‘çš„å…¬å…±ç¥–å…ˆæˆ–è€…æœ‰å³å­æ ‘çš„å…¬å…±ç¥–å…ˆï¼Œå°±è¿”å›å­æ ‘çš„ç¥–å…ˆï¼Œå¦åˆ™è¿”å›æ ¹èŠ‚ç‚¹

```Python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        
        if root is None:
            return None
        
        if root == p or root == q:
            return root
        
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        
        if left is not None and right is not None:
            return root
        elif left is not None:
            return left
        elif right is not None:
            return right
        else:
            return None
```

### BFS å±‚æ¬¡åº”ç”¨

### [binary-tree-zigzag-level-order-traversal](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„é”¯é½¿å½¢å±‚æ¬¡éå†ã€‚Z å­—å½¢éå†

- æ€è·¯ï¼šåœ¨BFSè¿­ä»£æ¨¡æ¿ä¸Šæ”¹ç”¨åŒç«¯é˜Ÿåˆ—æ§åˆ¶è¾“å‡ºé¡ºåº

```Python
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        
        levels = []
        if root is None:
            return levels
        
        s = collections.deque([root])

        start_from_left = True
        while len(s) > 0:
            levels.append([])
            level_size = len(s)
            
            if start_from_left:
                for _ in range(level_size):
                    node = s.popleft()
                    levels[-1].append(node.val)
                    if node.left is not None:
                        s.append(node.left)
                    if node.right is not None:
                        s.append(node.right)
            else:
                for _ in range(level_size):
                    node = s.pop()
                    levels[-1].append(node.val)
                    if node.right is not None:
                        s.appendleft(node.right)
                    if node.left is not None:
                        s.appendleft(node.left)
            
            start_from_left = not start_from_left
            
        
        return levels
```

### äºŒå‰æœç´¢æ ‘åº”ç”¨

### [validate-binary-search-tree](https://leetcode-cn.com/problems/validate-binary-search-tree/)

> ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚

- æ€è·¯ 1ï¼šä¸­åºéå†åæ£€æŸ¥è¾“å‡ºæ˜¯å¦æœ‰åºï¼Œç¼ºç‚¹æ˜¯å¦‚æœä¸å¹³è¡¡æ— æ³•æå‰è¿”å›ç»“æœï¼Œ ä»£ç ç•¥

- æ€è·¯ 2ï¼šåˆ†æ²»æ³•ï¼Œä¸€ä¸ªäºŒå‰æ ‘ä¸ºåˆæ³•çš„äºŒå‰æœç´¢æ ‘å½“ä¸”ä»…å½“å·¦å³å­æ ‘ä¸ºåˆæ³•äºŒå‰æœç´¢æ ‘ä¸”æ ¹ç»“ç‚¹å€¼å¤§äºå³å­æ ‘æœ€å°å€¼å°äºå·¦å­æ ‘æœ€å¤§å€¼ã€‚ç¼ºç‚¹æ˜¯è‹¥ä¸ç”¨è¿­ä»£å½¢å¼å®ç°åˆ™æ— æ³•æå‰è¿”å›ï¼Œè€Œè¿­ä»£å®ç°å³æ¯”è¾ƒå¤æ‚ã€‚

```Python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        
        if root is None: return True
        
        def valid_min_max(node):
            
            isValid = True
            if node.left is not None:
                l_isValid, l_min, l_max = valid_min_max(node.left)
                isValid = isValid and node.val > l_max
            else:
                l_isValid, l_min = True, node.val

            if node.right is not None:
                r_isValid, r_min, r_max = valid_min_max(node.right)
                isValid = isValid and node.val < r_min
            else:
                r_isValid, r_max = True, node.val

                
            return l_isValid and r_isValid and isValid, l_min, r_max
        
        return valid_min_max(root)[0]
```

- æ€è·¯ 3ï¼šåˆ©ç”¨äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ï¼Œæ ¹ç»“ç‚¹ä¸ºå·¦å­æ ‘çš„å³è¾¹ç•Œï¼Œå³å­æ ‘çš„å·¦è¾¹ç•Œï¼Œä½¿ç”¨å…ˆåºéå†è‡ªé¡¶å‘ä¸‹æ›´æ–°å·¦å³å­æ ‘çš„è¾¹ç•Œå¹¶æ£€æŸ¥æ˜¯å¦åˆæ³•ï¼Œè¿­ä»£ç‰ˆæœ¬å®ç°ç®€å•ä¸”å¯ä»¥æå‰è¿”å›ç»“æœã€‚

```Python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        
        if root is None:
            return True
        
        s = [(root, float('-inf'), float('inf'))]
        while len(s) > 0:
            node, low, up = s.pop()
            if node.left is not None:
                if node.left.val <= low or node.left.val >= node.val:
                    return False
                s.append((node.left, low, node.val))
            if node.right is not None:
                if node.right.val <= node.val or node.right.val >= up:
                    return False
                s.append((node.right, node.val, up))
        return True
```

### [insert-into-a-binary-search-tree](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

> ç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹å’Œè¦æ’å…¥æ ‘ä¸­çš„å€¼ï¼Œå°†å€¼æ’å…¥äºŒå‰æœç´¢æ ‘ã€‚ è¿”å›æ’å…¥åäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚

- æ€è·¯ï¼šå¦‚æœåªæ˜¯ä¸ºäº†å®Œæˆä»»åŠ¡åˆ™æ‰¾åˆ°æœ€åä¸€ä¸ªå¶å­èŠ‚ç‚¹æ»¡è¶³æ’å…¥æ¡ä»¶å³å¯ã€‚ä½†æ­¤é¢˜æ·±æŒ–å¯ä»¥æ¶‰åŠåˆ°å¦‚ä½•æ’å…¥å¹¶ç»´æŒå¹³è¡¡äºŒå‰æœç´¢æ ‘çš„é—®é¢˜ï¼Œå¹¶ä¸é€‚åˆåˆå­¦è€…ã€‚

```Python
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        
        if root is None:
            return TreeNode(val)
        
        node = root
        while True:
            if val > node.val:
                if node.right is None:
                    node.right = TreeNode(val)
                    return root
                else:
                    node = node.right
            else:
                if node.left is None:
                    node.left = TreeNode(val)
                    return root
                else:
                    node = node.left
```
