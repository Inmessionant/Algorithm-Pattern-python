# 最短路径



### 深度优先搜索模板

- 先序，递归

```Python
def DFS(x):
    visit(x)
    for n in neighbor(x):
        if not visited(n):
            DFS(n)
    return
```

- 先序，迭代，出栈时访问

```Python
def DFS(x):
    dfs = [x] # implement by a stack
    while dfs:
        v = dfs.pop()
        if not visited(v):
            visit(v)
            for n in neighbor(v):
                if not visited(n):
                    dfs.append(n)
    return
```

- 后序，递归

```Python
def DFS(x): # used when need to aggregate results from children
    discovering(x)
    for n in neighbor(x):
        if not discovering(n) and not visited(n):
            DFS(n)
    visit(x)
    return
```

### 广度优先搜索模板

相对于 dfs 可能收敛更慢，但是可以用来找不带权的最短路径

- 以结点为单位搜索

```Python
def BFS(x):
    visit(x)
    bfs = collections.deque([x])
    while bfs:
        v = bfs.popleft()
        for n in neighbor(v):
            if not visited(n):
                visit(n)
                bfs.append(n)
    return
```

- 以层为单位搜索，典型应用是找不带权的最短路径

```Python
def BFS(x):
    visit(x)
    bfs = collections.deque([x])
    while bfs:
        num_level = len(bfs)
        for _ in range(num_level)
            v = bfs.popleft()
            for n in neighbor(v):
                if not visited(v):
                    visit(n)
                    bfs.append(n)
    return
```



## BFS

在处理不带权图的最短路径问题时可以使用 BFS。



### ✅[墙与门 x](https://leetcode-cn.com/problems/walls-and-gates/)

- 思路：典型的多源最短路径问题，将所有源作为 BFS 的第一层即可

```Python
inf = 2147483647

class Solution:
    def wallsAndGates(self, rooms: List[List[int]]) -> None:
        """
        Do not return anything, modify rooms in-place instead.
        """
        
        if not rooms or not rooms[0]:
            return
        
        M, N = len(rooms), len(rooms[0])
        
        bfs = collections.deque([])
        
        for i in range(M):
            for j in range(N):
                if rooms[i][j] == 0:
                    bfs.append((i, j))
        
        dist = 1
        while bfs:
            num_level = len(bfs)
            for _ in range(num_level):
                x, y = bfs.popleft()
                
                for i, j in [[-1, 0], [1, 0], [0, 1], [0, -1]]:
                	curx = i + x
                	cury = j + y

                	if  0 <= curx < M and 0 <= cury < N and rooms[curx][cury] == inf:
                    	rooms[curx][cury] = dist
                    	bfs.append((curx, cury))
            
            dist += 1
        
        return
```



### ✅[最短的桥 x](https://leetcode-cn.com/problems/shortest-bridge/)

- 思路：DFS 遍历找到两个岛屿，把其中一个改成2，从边界开始 BFS找最短路径

1 遍历矩阵，找到的一个1，调用dfs把和1联通的所有1改成2；
2 调用bfs把第一个岛向周围扩散（即把它把周围的0改为2），直到在某次扩散时遇到1，说明已经遇到了另一个岛，此时返回扩散的次数即可。
变量说明：q双端队列，存储第一个岛； steps存储bfs的扩散的次数；dirs存储上下左右4个方向

```Python
class Solution:
    def shortestBridge(self, A: List[List[int]]) -> int:
        def dfs(i, j):
            A[i][j] = 2
            queue.append((i, j))
            for x , y in dirs:
                curx = x + i
                cury = y + j
                if 0 <= curx < len(A) and 0 <= cury < len(A[0]) and A[curx][cury] == 1:
                    dfs(curx, cury)

        def bfs(i, j):
            step = 0
            while queue:
                level = len(queue)
                for _ in range(level):
                    i, j = queue.popleft()
                    for x, y in dirs:
                        curx = x + i
                        cury = y + j
                        if 0 <= curx < len(A) and 0 <= cury < len(A[0]) and A[curx][cury] == 1:
                            return step
                        elif 0 <= curx < len(A) and 0 <= cury < len(A[0]) and A[curx][cury] == 0:
                            A[curx][cury] = 2
                            queue.append((curx, cury))
                    step += 1 
                        

        dirs = ((-1, 0), (1, 0), (0, -1), (0, 1))
        queue = deque()

        for i in range(len(A)):
            for j in range(len(A[0])):
                if A[i][j] == 1:
                    dfs(i, j)
                    return bfs(i, j)
```





## Dijkstra's Algorithm



该算法无法判断是否存在负权环路，如果存在，算法将失效

实现上是 greedy + heap 的一个应用，用于求解图的单源最短路径相关的问题，生成的树为最短路径树 (SPT)





用于求解单源最短路径问题。思想是 greedy 构造 shortest path tree (SPT)，每次将当前距离源点最短的不在 SPT 中的结点加入SPT，与构造最小生成树 (MST) 的 Prim's algorithm 非常相似。可以用 priority queue (heap) 实现。

### ✅[网络延迟时间 x](https://leetcode-cn.com/problems/network-delay-time/)

- 标准的单源最短路径问题，使用朴素的的 Dijikstra 算法即可，可以当成模板使用；

```Python
class Solution:
    def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:
        
        # construct graph
        graph_neighbors = collections.defaultdict(list)
        for s, e, t in times:
            graph_neighbors[s].append((e, t))
        
        SPT = {}
        mini_heap = [(0, K)]

        # Dijkstra
        while mini_heap:
            delay, node = heapq.heappop(mini_heap)
            if node not in SPT:
                SPT[node] = delay
                for n, d in graph_neighbors[node]:
                    if n not in SPT:
                        heapq.heappush(mini_heap, (d + delay, n))

        return max(SPT.values()) if len(SPT) == N else -1
```



### ✅[ K 站中转内最便宜的航班 x](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)

- 在标准的单源最短路径问题上限制了路径的边数，因此需要同时维护当前 SPT 内每个结点最短路径的边数，当遇到边数更小的路径 (边权和可以更大) 时结点需要重新入堆，以更新后继在边数上限内没达到的结点

```Python
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        
        # construct graph
        graph_neighbor = collections.defaultdict(list)
        for s, e, p in flights:
            graph_neighbor[s].append((e, p))
        
        # modified Dijkstra
        prices, steps = {}, {}
        min_heap = [(0, 0, src)] # price, step, node
        
        while min_heap:
            price, step, node = heapq.heappop(min_heap)
            
            if node == dst: # early return
                return price

            if node not in prices:
                prices[node] = price
            
            steps[node] = step
            if step <= K:
                step += 1
                for n, p in graph_neighbor[node]:
                    if n not in prices or step < steps[n]:
                        heapq.heappush(min_heap, (p + price, step, n))
        
        return -1
```



## Floyd

算法步骤
通过已知条件初始化距离矩阵`D[n][n]`，其中`D[i`][j]表示，顶点i到顶点j的距离。

n个顶点依次作为插入点，例如，k为其中一个顶点，`D[i][k] + D[k][j] < D[i`][j]，那说明顶点i经过顶点k再到达j，比直接到达j要近。所以更新`D[i][j]：D[i][j] = D[i][k] + D[k][j]`。

可以归纳得到状态转移方程：`D[i][j] = min(D[i,k]+D[k,j],D[i,j])`;

```python
// Floyd算法
for (int k = 0; k < n; k++) {
// n个顶点依次作为插入点
// 注意插点k是放在第一层循环，后面会解释原因
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            // 遍历各个顶点之间的距离，并用插入点进行更新
            D[i][j] = min(D[i][k]+D[k][j], D[i][j]);
        }
    }
}
```



使用Floyd算法求出各个城市到其它城市的距离，保存在矩阵D[n][n]中。

遍历D[n][n]，统计各个城市在距离不超过 distanceThreshold 的情况下，能到达的其它城市的数量。

返回能到达其它城市最少的城市 ret。

### ✅[阈值距离内邻居最少的城市 x](https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/)

```python
class Solution:
    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:
        
        # 初始化：最开始任意两点的距离都设置为最大值
        floyd = [[float("inf") for _ in range(n)]for _ in range(n)]

         # 注意：这里是无向图
        for i, j, dist in edges:
            floyd[i][j] = dist
            floyd[j][i] = dist
        
        # 计数任意两个点的最短距离
        for k in range(n):
            for i in range(n):
                for j in range(n):
                    floyd[i][j] = min(floyd[i][j], floyd[i][k] + floyd[k][j])
        
        ret = 0
        min_cnt = float("inf")

         # 计算任意两个点最短距离满足题目要求的点
        for i in range(n):
            cnt = 0
            for j in range(n):
                if i != j and floyd[i][j] <= distanceThreshold: # 从i点出发，到任意一个点距离小于阈值的个数
                    cnt += 1
            if  min_cnt >= cnt:
                min_cnt = cnt
                ret = i

        return ret    
```



## Bidrectional BFS

当求点对点的最短路径时，BFS遍历结点数目随路径长度呈指数增长，为缩小遍历结点数目可以考虑从起点 BFS 的同时从终点也做 BFS，当路径相遇时得到最短路径。

### [word-ladder](https://leetcode-cn.com/problems/word-ladder/)

```Python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
        N, K = len(wordList), len(beginWord)
        
        find_end = False
        for i in range(N):
            if wordList[i] == endWord:
                find_end = True
                break
        
        if not find_end:
            return 0
        
        wordList.append(beginWord)
        N += 1
        
        # clustering nodes for efficiency compare to adjacent list
        cluster = collections.defaultdict(list)
        for i in range(N):
            node = wordList[i]
            for j in range(K):
                cluster[node[:j] + '*' + node[j + 1:]].append(node)
        
        # bidirectional BFS
        visited_start, visited_end = set([beginWord]), set([endWord])
        bfs_start, bfs_end = collections.deque([beginWord]), collections.deque([endWord])
        step = 2
        while bfs_start and bfs_end:
          
            # start
            num_level = len(bfs_start)
            while num_level > 0:
                node = bfs_start.popleft()
                for j in range(K):
                    key = node[:j] + '*' + node[j + 1:]
                    for n in cluster[key]:
                        if n in visited_end: # if meet, route from start larger by 1 than route from end
                            return step * 2 - 2
                        if n not in visited_start:
                            visited_start.add(n)
                            bfs_start.append(n)
                num_level -= 1
            
            # end
            num_level = len(bfs_end)
            while num_level > 0:
                node = bfs_end.popleft()
                for j in range(K):
                    key = node[:j] + '*' + node[j + 1:]
                    for n in cluster[key]:
                        if n in visited_start: # if meet, route from start equals route from end
                            return step * 2 - 1
                        if n not in visited_end:
                            visited_end.add(n)
                            bfs_end.append(n)
                num_level -= 1
            step += 1
        
        return 0
```



## A* Algorithm

当需要求解有目标的最短路径问题时，BFS 或 Dijkstra's algorithm 可能会搜索过多冗余的其他目标从而降低搜索效率，此时可以考虑使用 A* algorithm。原理不展开，有兴趣可以自行搜索。实现上和 Dijkstra’s algorithm 非常相似，只是优先级需要加上一个到目标点距离的估值，这个估值严格小于等于真正的最短距离时保证得到最优解。当 A* algorithm 中的距离估值为 0 时 退化为 BFS 或 Dijkstra’s algorithm。

### [sliding-puzzle](https://leetcode-cn.com/problems/sliding-puzzle)

- 方法 1：BFS。为了方便对比 A* 算法写成了与其相似的形式。

```Python
class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        
        next_move = {
            0: [1, 3],
            1: [0, 2, 4],
            2: [1, 5],
            3: [0, 4],
            4: [1, 3, 5],
            5: [2, 4]
        }
        
        start = tuple(itertools.chain(*board))
        target = (1, 2, 3, 4, 5, 0)
        target_wrong = (1, 2, 3, 5, 4, 0)
        
        SPT = set()
        bfs = collections.deque([(0, start, start.index(0))])
        
        while bfs:
            step, state, idx0 = bfs.popleft()
            
            if state == target:
                return step
            
            if state == target_wrong:
                return -1
            
            if state not in SPT:
                SPT.add(state)
                
                for next_step in next_move[idx0]:
                    next_state = list(state)
                    next_state[idx0], next_state[next_step] = next_state[next_step], next_state[idx0]
                    next_state = tuple(next_state)

                    if next_state not in SPT:
                        bfs.append((step + 1, next_state, next_step))
        return -1
```

- 方法 2：A* algorithm

```Python
class Solution:
    def slidingPuzzle(self, board: List[List[int]]) -> int:
        
        next_move = {
            0: [1, 3],
            1: [0, 2, 4],
            2: [1, 5],
            3: [0, 4],
            4: [1, 3, 5],
            5: [2, 4]
        }
        
        start = tuple(itertools.chain(*board))
        target, target_idx = (1, 2, 3, 4, 5, 0), (5, 0, 1, 2, 3, 4)
        target_wrong = (1, 2, 3, 5, 4, 0)
        
        @functools.lru_cache(maxsize=None)
        def taxicab_dist(x, y):
            return abs(x // 3 - y // 3) + abs(x % 3 - y % 3)
        
        def taxicab_sum(state, t_idx):
            result = 0
            for i, num in enumerate(state):
                result += taxicab_dist(i, t_idx[num])
            return result

        SPT = set()
        min_heap = [(0 + taxicab_sum(start, target_idx), 0, start, start.index(0))]
        
        while min_heap:
            cur_cost, step, state, idx0 = heapq.heappop(min_heap)
            
            if state == target:
                return step
            
            if state == target_wrong:
                return -1
            
            if state not in SPT:
                SPT.add(state)
            
                for next_step in next_move[idx0]:
                    next_state = list(state)
                    next_state[idx0], next_state[next_step] = next_state[next_step], next_state[idx0]
                    next_state = tuple(next_state)
                    next_cost = step + 1 + taxicab_sum(next_state, target_idx)
                    
                    if next_state not in SPT:
                        heapq.heappush(min_heap, (next_cost, step + 1, next_state, next_step))
        return -1
```

