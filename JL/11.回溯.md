# 回溯



## 基础



回溯法（backtrack）常用于遍历列表所有子集，是 DFS 深度搜索一种，一般用于全排列，穷尽所有可能，遍历的过程实际上是一个决策树的遍历过程。时间复杂度一般 O(N!)，它不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高



**组合 ，排列，切割，子集，棋盘**



**回溯法解决的问题都可以抽象为树形结构（n叉树）**

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**



如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，**「那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！」**



![回溯算法理论基础](https://camo.githubusercontent.com/f65ca647f31913496481cd1aff144040bd7ee4f6bc30accd370bc78b4b265d13/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303133303137333633313137342e706e67)



**模板**

```go
result = []
func backtrack(选择列表,路径):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        做选择
        backtrack(选择列表,路径)
        撤销选择
```

核心就是从选择列表里做一个选择，然后一直递归往下搜索答案，如果遇到路径不通，就返回来撤销这次选择



**针对有重复的解，我们在最开始要对nums排序，之后再res.append()时候只需判断path是否在res内即可**



## 子集



### ✅[子集 x](https://leetcode-cn.com/problems/subsets/)

遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合

```Python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        result = []
        nums = sorted(nums)

        def backtrack(start, path):
            result.append(path[:])

            if start >= len(nums): return

            for i in range(start, len(nums)):
                path.append(nums[i])
                backtrack(i + 1, path)
                path.pop()

        backtrack(0, [])
        return result
```

用子集II思路也能做，即：用的组合思路，将包含0，1，2，.. len(nums)分开处理，但是要注意去重，第一个开始为2处理过之后，第二个开始为2的组合肯定有重复，所以需要判断一下

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:

        nums = sorted(nums)
        result = []

        def backtrack(start, k, path):
            if len(path) == k and path not in result:
                result.append(path[:])
                return 
            for i in range(start, len(nums)):
                path.append(nums[i])
                backtrack(i + 1, k, path)
                path.pop()
        
        for k in range(len(nums) + 1):
            backtrack(0, k, [])

        return result
```



### ✅[子集 II x](https://leetcode-cn.com/problems/subsets-ii/)

用的组合思路，将包含0，1，2，.. len(nums)分开处理，但是要注意去重，第一个开始为2处理过之后，第二个开始为2的组合肯定有重复，所以需要判断一下

```Python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:

        nums = sorted(nums)
        result = []

        def backtrack(start, k, path):
            if len(path) == k and path not in result: //可能会有重复需要去重
                result.append(path[:])
                return 
            for i in range(start, len(nums)):
                path.append(nums[i])
                backtrack(i + 1, k, path)
                path.pop()
        
        for k in range(len(nums) + 1):
            backtrack(0, k, [])

        return result
```



### ✅[递增子序列 x](https://leetcode-cn.com/problems/increasing-subsequences/)

```python
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        res = []
        if len(nums) < 2: return res

        def backtrack(start, nums, path):
            if len(path) > 1:
                if path[-1] >= path[-2]:
                	res.append(path[:])
                else:
                    return

            for i in range(start, len(nums)):
                if nums[i] in nums[start:i]: # 同层上使用过的元素就不能再使用了
                    continue
                path.append(nums[i])
                backtrack(i + 1, nums, path)
                path.pop()           
        
        backtrack(0, nums, [])

        return res
```



------



## 组合



### [组合 x](https://leetcode-cn.com/problems/combinations/)

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        res, path = [], []

        def backtrack(start, n, k):

            if len(path) == k:
                res.append(path[:])
                return

            for i in range(start, n + 1):
                path.append(i)
                backtrack(i + 1, n, k)
                path.pop()

        backtrack(1, n, k)   

        return res     
```

**剪枝**

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:

        res = []

        def  backtrack(start, n, k, path):
            if len(path) == k:
                res.append(path[:])
                return 
            for i in range(start, n - k + len(path) + 2): #  n - (k - len(path)) + 1 + 1
                path.append(i)
                backtrack(i + 1, n, k, path)
                path.pop()

        
        backtrack(1, n, k, [])
        return res
```



### [组合总和 III x](https://leetcode-cn.com/problems/combination-sum-iii/)

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        result = []

        def backtrack(start, path, sumpath):
            if sumpath > n: return 
            if len(path) == k and sumpath == n:
                result.append(path[:])
                return 
            for i in range(start, 10):
                path.append(i)
                sumpath += i
                backtrack(i + 1, path, sumpath)
                sumpath -= path.pop()

        backtrack(1, [], 0)
        return result 
```

**剪枝**

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        
        res, path = [], []

        def backtrack(start, k, n, sumpath):

            if sumpath > n: return  # 剪枝
            if len(path) == k and sumpath == n:
                res.append(path[:])
                return
            
            for i in range(start, 9 - k + len(path) + 2): # 9 - (k - len(path)) + 1 + 1
                sumpath += i
                path.append(i)
                backtrack(i + 1, k, n, sumpath)
                sumpath -= path.pop()
        
        backtrack(1, k, n, 0)

        return res
```



### [电话号码的字母组合 x](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```Python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:

        res, path = [], []
        if not digits: return res

        def backtrack(start): # start指向下一个选的dights数字位置

            if start == len(digits): # 当start移动到n - 1，backtrack(start + 1)时，start == n
                res.append(''.join(path[:]))
                return
            
            for char in num2char[digits[start]]:
                path.append(char)
                backtrack(start + 1)
                path.pop()            
        
        num2char = {
            '2': ['a', 'b', 'c'],
            '3': ['d', 'e', 'f'],
            '4': ['h', 'i', 'g'],
            '5': ['j', 'k', 'l'],
            '6': ['m', 'n', 'o'],
            '7': ['p', 'q', 'r', 's'],
            '8': ['t', 'u', 'v'],
            '9': ['w', 'x', 'y', 'z']
        }

        backtrack(0)

        return res
```



### [组合总和 x](https://leetcode-cn.com/problems/combination-sum/)

```Python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:

        res, path = [], []

        def backtrack(start, sumpath, candidates, target):

            if sumpath > target:  # 剪枝
                return
            if sumpath == target:
                res.append(path[:])
                return

            for i in range(start, len(candidates)):
                sumpath += candidates[i]
                path.append(candidates[i])
                backtrack(i, sumpath, candidates, target) # 关键点:不用i+1了，表示candidates 中的数字可以重复读取当前的数
                sumpath -= path.pop()
        
        backtrack(0, 0, candidates, target)

        return res
```



### ✅[组合总和 II x](https://leetcode-cn.com/problems/combination-sum-ii/)

- 组合问题去重；
- 本题数组candidates的元素是有重复的，上一题数组candidates的元素是无重复；
- **在搜索的过程中就去掉重复组合，所谓去重，其实就是使用过的元素不能重复选取，**都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。**没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因**；
- 回看一下题目，元素在同一个组合内是可以重复的，但两个组合不能相同，**所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重**；
- **树层去重的话，需要对数组排序**；



```python

```



## 排列



### ✅[全排列 x](https://leetcode-cn.com/problems/permutations/)

```Python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        nums = sorted(nums)
        res = []
        visited = [False for _ in range(len(nums))]

        def backtrack(path):
            if len(path) == len(nums):
                res.append(path[:])
                return
            
            for i in range(len(nums)):
                if not visited[i]:
                    path.append(nums[i])
                    visited[i] = True
                    backtrack(path)
                    path.pop()
                    visited[i] = False
        
        backtrack([])
        return res
```



### [✅全排列 II x](https://leetcode-cn.com/problems/permutations-ii/)

```Python
class Solution:x
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        nums = sorted(nums) # 用来配合去重
        res = []
        visited = [False for _ in range(len(nums))]

        def backtrack(path):
            if len(path) == len(nums) and path not in res: # 用  path not in res 去重
                res.append(path[:])
                return
            
            for i in range(len(nums)):
                if not visited[i]:
                    path.append(nums[i])
                    visited[i] = True
                    backtrack(path)
                    path.pop()
                    visited[i] = False
        
        backtrack([])
        return res
```



------



## 切割



### ✅[分割回文串 x](https://leetcode-cn.com/problems/palindrome-partitioning/)

```Python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        res = []
        
        def backtrack(start, path):
            if start == len(s):
                res.append(path[:])
                return
            for i in range(start, len(s)):
                if s[start:i+1] == s[start:i+1][::-1]:
                    path.append(s[start:i+1])
                else:
                    continue
                backtrack(i+1, path)
                path.pop()
        
        backtrack(0, [])

        return res
```



### ✅[复原 IP 地址 x](https://leetcode-cn.com/problems/restore-ip-addresses/)

```Python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        if len(s) < 4 or len(s) > 12:   return  res

        def isValid(s, start, end): 
            if start > end:
                return False
            if s[start] == '0' and start != end:
                return False
            if int(s[start: end+1]) < 0 or int(s[start: end+1]) > 255:
                return False

            return True
        


        def backtrack(s, start, pointNum):
            if pointNum == 3 and isValid(s, start, len(s)-1):
                res.append(s)
                return
            for i in range(start, len(s)):
                if isValid(s, start, i):
                    s = s[:i+1] + '.' + s[i+1:]
                    pointNum += 1
                    backtrack(s, i+2, pointNum)
                    pointNum -= 1
                    s = s[:i+1] + s[i+2:]
                else:
                    break
        
        backtrack(s, 0, 0)
        return res
```





