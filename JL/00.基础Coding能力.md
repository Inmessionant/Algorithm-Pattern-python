### [顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

https://leetcode-cn.com/problems/spiral-matrix/

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return list()
        
        rows, columns = len(matrix), len(matrix[0])
        order = list()
        left, right, top, bottom = 0, columns - 1, 0, rows - 1
        while left <= right and top <= bottom:
            for column in range(left, right + 1):
                order.append(matrix[top][column])
            for row in range(top + 1, bottom + 1):
                order.append(matrix[row][right])
            if left < right and top < bottom: # 排除rows=1或者columns=1情况，以及最后一行或者一列时候的输出
                for column in range(right - 1, left, -1):
                    order.append(matrix[bottom][column])
                for row in range(bottom, top, -1):
                    order.append(matrix[row][left])
            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1
        return order
```



### 之字形打印矩阵

```python
class Solution:
    def __init__(self):
        self.result = []

    def ZigzagPrintMatrix(self, arr):
        tc, tr = 0, 0  # 主对角线上面的点
        bc, br = 0, 0  # 主对角线下面的点
        endr, endc = len(arr) - 1, len(arr[0]) - 1
        flag = False  # False左上到右下打印
        while tr != endr + 1:
            self.printlevel(arr, tc, tr, bc, br, flag)

            # 下面四句改变顺序会报错(if判断条件的原因)
            tr = tr + 1 if tc == endc else tr
            tc = tc if tc == endc else tc + 1

            bc = bc + 1 if br == endr else bc
            br = br if br == endr else br + 1

            flag = not flag

        return self.result

    def printlevel(self, arr, tc, tr, bc, br, flag):
        if flag == False:
            while br != tr - 1:
                self.result.append(arr[br][bc])
                br -= 1
                bc += 1
        else:
            while tr != br + 1:
                self.result.append(arr[tr][tc])
                tr += 1
                tc -= 1


if __name__ == "__main__":
    matrix = []
    n = int(input())

    for _ in range(n):
        matrix.append(list(map(int, input().split(' '))))

    print(matrix)

    solution = Solution()
    res = solution.ZigzagPrintMatrix(matrix)
    for re in res:
        print(re, end=' ')

```



### [路径交叉](https://leetcode-cn.com/problems/self-crossing/)

```python
class Solution:
    def isSelfCrossing(self, distance: List[int]) -> bool:

        n = len(distance)

        if not distance or n < 4:
            return False
        
        # 基础情况
        if n > 3 and distance[2] <= distance[0] and distance[3] >= distance[1]:
            return True
        if n > 4 and distance[3] <= distance[1] and distance[4] >= distance[2]:
            return True
        if n > 4 and distance[1] == distance[3] and distance[4] + distance[0] >= distance[2]:
            return True

        # 开始遍历
        for i in range(5, n):
            if distance[i - 1] <= distance[i - 3] and distance[i] >= distance[i - 2]:
                return True
            if distance[i - 1] <= distance[i - 3] and distance[i - 2] >= distance[i -4] and distance[i -5] + distance[i - 1] >= distance[ i - 3] and distance[i] + distance[i - 4] >= distance[i - 2]:
                return True
        
        return False
```



### [完美矩形](https://leetcode-cn.com/problems/perfect-rectangle/)

```python
class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
        # recx1, recy1, recx2, recy2 the points of the large rectangle.
        recx1, recy1, recx2, recy2 = float("inf"), float("inf"),float("-inf"),float("-inf")
        sumarea = 0
        visited_point = set()
        # x1, y1, x2, y2: the points of the small rectangle.
        for x1, y1, x2, y2 in rectangles:
            recx1, recy1, recx2, recy2 = min(recx1, x1), min(recy1, y1), max(recx2, x2), max(recy2, y2)
            sumarea += (x2 - x1) * (y2 - y1)
            
            points = [(x1, y1), (x2, y2), (x1, y2), (x2, y1)] # 小矩形四个顶点
            
            for point in points:
                if point in visited_point:
                    visited_point.remove(point)
                else:
                    visited_point.add(point)
        
        exceptedarea = (recx2 - recx1) * (recy2 - recy1)
        if sumarea != exceptedarea:
            return False
        if len(visited_point) != 4:
            return False
        
        recpoints = set([(recx1, recy1), (recx2, recy2), (recx1, recy2), (recx2, recy1)])
        return recpoints == visited_point
```



### [字符串相加](https://leetcode-cn.com/problems/add-strings/)

```python
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:

        res  =""
        i1, i2 = len(num1) - 1, len(num2) - 1
        carry = 0

        while i1 >= 0 or i2 >= 0:
            n1 = ord(num1[i1]) - ord("0") if i1 >= 0 else 0
            n2 = ord(num2[i2]) - ord("0") if i2 >= 0 else 0
            tmp = n1 + n2 + carry
            carry = tmp // 10
            res = str(tmp % 10) + res
            i1, i2 = i1 - 1, i2 - 1
        
        return "1" + res if carry else res 
```

