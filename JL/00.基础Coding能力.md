### [顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

https://leetcode-cn.com/problems/spiral-matrix/

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix or not matrix[0]:
            return list()
        
        rows, columns = len(matrix), len(matrix[0])
        order = list()
        left, right, top, bottom = 0, columns - 1, 0, rows - 1
        while left <= right and top <= bottom:
            for column in range(left, right + 1):
                order.append(matrix[top][column])
            for row in range(top + 1, bottom + 1):
                order.append(matrix[row][right])
            if left < right and top < bottom: # 排除rows=1或者columns=1情况，以及最后一行或者一列时候的输出
                for column in range(right - 1, left, -1):
                    order.append(matrix[bottom][column])
                for row in range(bottom, top, -1):
                    order.append(matrix[row][left])
            left, right, top, bottom = left + 1, right - 1, top + 1, bottom - 1
        return order
```



### 之字形打印矩阵

```python
class Solution:
    def __init__(self):
        self.result = []

    def ZigzagPrintMatrix(self, arr):
        tc, tr = 0, 0  # 主对角线上面的点
        bc, br = 0, 0  # 主对角线下面的点
        endr, endc = len(arr) - 1, len(arr[0]) - 1
        flag = False  # False左上到右下打印
        while tr != endr + 1:
            self.printlevel(arr, tc, tr, bc, br, flag)

            # 下面四句改变顺序会报错(if判断条件的原因)
            tr = tr + 1 if tc == endc else tr
            tc = tc if tc == endc else tc + 1

            bc = bc + 1 if br == endr else bc
            br = br if br == endr else br + 1

            flag = not flag

        return self.result

    def printlevel(self, arr, tc, tr, bc, br, flag):
        if flag == False:
            while br != tr - 1:
                self.result.append(arr[br][bc])
                br -= 1
                bc += 1
        else:
            while tr != br + 1:
                self.result.append(arr[tr][tc])
                tr += 1
                tc -= 1


if __name__ == "__main__":
    matrix = []
    n = int(input())

    for _ in range(n):
        matrix.append(list(map(int, input().split(' '))))

    print(matrix)

    solution = Solution()
    res = solution.ZigzagPrintMatrix(matrix)
    for re in res:
        print(re, end=' ')

```



### [路径交叉](https://leetcode-cn.com/problems/self-crossing/)

```python
class Solution:
    def isSelfCrossing(self, distance: List[int]) -> bool:

        n = len(distance)

        if not distance or n < 4:
            return False
        
        # 基础情况
        if n > 3 and distance[2] <= distance[0] and distance[3] >= distance[1]:
            return True
        if n > 4 and distance[3] <= distance[1] and distance[4] >= distance[2]:
            return True
        if n > 4 and distance[1] == distance[3] and distance[4] + distance[0] >= distance[2]:
            return True

        # 开始遍历
        for i in range(5, n):
            if distance[i - 1] <= distance[i - 3] and distance[i] >= distance[i - 2]:
                return True
            if distance[i - 1] <= distance[i - 3] and distance[i - 2] >= distance[i -4] and distance[i -5] + distance[i - 1] >= distance[ i - 3] and distance[i] + distance[i - 4] >= distance[i - 2]:
                return True
        
        return False
```



### [完美矩形](https://leetcode-cn.com/problems/perfect-rectangle/)

```python
class Solution:
    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:
        # recx1, recy1, recx2, recy2 the points of the large rectangle.
        recx1, recy1, recx2, recy2 = float("inf"), float("inf"),float("-inf"),float("-inf")
        sumarea = 0
        visited_point = set()
        # x1, y1, x2, y2: the points of the small rectangle.
        for x1, y1, x2, y2 in rectangles:
            recx1, recy1, recx2, recy2 = min(recx1, x1), min(recy1, y1), max(recx2, x2), max(recy2, y2)
            sumarea += (x2 - x1) * (y2 - y1)
            
            points = [(x1, y1), (x2, y2), (x1, y2), (x2, y1)] # 小矩形四个顶点
            
            for point in points:
                if point in visited_point:
                    visited_point.remove(point)
                else:
                    visited_point.add(point)
        
        exceptedarea = (recx2 - recx1) * (recy2 - recy1)
        if sumarea != exceptedarea:
            return False
        if len(visited_point) != 4:
            return False
        
        recpoints = set([(recx1, recy1), (recx2, recy2), (recx1, recy2), (recx2, recy1)])
        return recpoints == visited_point
```



### [字符串相加](https://leetcode-cn.com/problems/add-strings/)

```python
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:

        res  =""
        i1, i2 = len(num1) - 1, len(num2) - 1
        carry = 0

        while i1 >= 0 or i2 >= 0:
            n1 = ord(num1[i1]) - ord("0") if i1 >= 0 else 0
            n2 = ord(num2[i2]) - ord("0") if i2 >= 0 else 0
            tmp = n1 + n2 + carry
            carry = tmp // 10
            res = str(tmp % 10) + res
            i1, i2 = i1 - 1, i2 - 1
        
        return "1" + res if carry else res 
```



### [乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:

        if not nums: return 0
        res, premin, premax = nums[0], nums[0], nums[0]

        for i in range(1, len(nums)):
            curmax = max(nums[i], premax * nums[i], premin * nums[i])
            curmin = min(nums[i], premax * nums[i], premin * nums[i])
            res = max(res, curmax)
            premax, premin = curmax, curmin
        
        return res
```



### [矩形区域不超过 K 的最大数值和](https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/)

```python
    # 这里是 leetcode 363 的题解，用于参考
    # 1、先计算每列的前缀和
    # 2、计算每行的最大子数组和
    # 固定左右边界，前缀和+二分
    # 划分左右边界，并求出在此边界下，每行的总和
    # 通过二分法找不超过K的矩阵
    # 当然以行划分也行，为什么要以列为边界，因为题目中说了 如果行数远大于列数
    # https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/solution/gu-ding-zuo-you-bian-jie-qian-zhui-he-er-fen-by-po/
    def maxSumSubmatrix(self, matrix: List[List[int]], k: int) -> int:
        row = len(matrix)
        col = len(matrix[0])
        res = float("-inf")
        for left in range(col):                     #从左到右，从上到下，滚动遍历
            colSum = [0] * row                      #以left为左边界，每行的总和
            for right in range(left, col):          #这一列每一位为右边界
                for i in range(row):                #遍历列中每一位，计算前缀和
                    colSum[i] += matrix[i][right]
                
                res = max(res, self.dpmax2(colSum, k))# 在left，right为边界下的矩阵，求不超过K的最大数值和
                if res==k:return k
        return res

    # Kadane’s algorithm
    # O(n)
    # 最大子片段的和
    # 遍历该数组， 遍历之前设置了两个变量 max_ending_here, max_so_far
    # 其中 max_ending_here 用于记录遍历过程中， 如果把当前元素 x 强制规定为子数列的最后一个元素时， 能找到的最大子数列的总和是多少
    # 由于真正的最大子数列必然存在一个结尾元素， 所以只需要从每个位置计算出的 max_ending_here 中， 找到最大值， 就是全局的最大子数列的值。
    # max_so_far 用于记录遍历过程中， 所发现的最大的 max_ending_here
    # 一次遍历之后， 变量 max_so_far 中存储的即为最大子片段的和值。
    # https://blog.csdn.net/lengxiao1993/article/details/52303492
    def dpmax2(self, colSum, k):
        max_ending_here = max_so_far = colSum[0]
        for i in range(1, len(colSum)):
            max_ending_here = max(colSum[i], max_ending_here + colSum[i])
            max_so_far = max(max_so_far, max_ending_here)
        return min(max_so_far, k)
```



### [面试题 17.24. 最大子矩阵](https://leetcode-cn.com/problems/max-submatrix-lcci/)

```python
    #leetcode 363 代码套路一样
    def getMaxMatrix(self, matrix: List[List[int]]) -> List[int]:
        row = len(matrix)
        col = len(matrix[0])
        maxArea = float('-inf')                     #最大面积
        res = [0, 0, 0, 0]

        for left in range(col):                     #从左到右，从上到下，滚动遍历
            colSum = [0] * row                      #以left为左边界，每行的总和
            for right in range(left, col):          #这一列每一位为右边界
                for i in range(row):                #遍历列中每一位，计算前缀和
                    colSum[i] += matrix[i][right]

                startX, endX, maxAreaCur= self.getMax(colSum)#在left，right为边界下的矩阵中，前缀和colSum的最大值
                if maxAreaCur > maxArea:
                    res = [startX, left, endX, right]        #left是起点y轴坐标，right是终点y轴坐标
                    maxArea = maxAreaCur
        return res
    
    #这一列中，找最大值，同时记录起点，终点
    #因为传进来的是列的前缀和，所以返回的起点、终点代表的是行坐标
    def getMax(self, nums):
        n = len(nums)
        maxVal, curSum = nums[0], nums[0]       #初始化最大值
        startIndex, end, start = 0, 0, 0        #初始化临时起点，起点，终点
        for i in range(1,n):
            if curSum<0:                        #前缀和小于0了，前面就不要了，从当前开始
                curSum = nums[i]
                startIndex = i                  #前面的前缀和小于0了，需要重置起点，从当前开始才有可能成为最大值
            else:
                curSum = curSum + nums[i]
            
            if curSum > maxVal:
                maxVal = curSum
                start = startIndex             #记录下前面的起点，默认0，或者是curSum<0后，重新更新的起点
                end = i                        #终点是当前坐标
        return start, end, maxVal              #起点，终点，最大前缀和（最大面积）
```

