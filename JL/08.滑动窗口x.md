# 滑动窗口



## 示例



### ✅[长度最小的子数组 x](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        res = n + 1
        l, r = 0, 0
        sum = 0

        while r < n:
            sum += nums[r]
            while sum >= target:
                res = min(res, r - l + 1)
                sum -= nums[l]
                l += 1
            r += 1
        
        return 0 if res == n + 1 else res
```



### ✅[最小覆盖子串 x](https://leetcode-cn.com/problems/minimum-window-substring/)

https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-by-powcai-2/

```Python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        need = defaultdict(int) # 存储t中的元素，代表在当前窗口下，26个字母的匹配情况，0是刚好匹配，负数是有多余的字符，正数是还需要匹配的字符
        for c in t:
            need[c] += 1
        l, r = 0, 0
        min_len, res = float("inf"), ""
        counter = len(t) #counter 用于存储当前窗口与t未匹配的字符，当counter = 0 时，窗口字符串完全包含t

        while r < len(s):

            if need[s[r]] > 0: # 表示匹配上了t中的字符
                counter -= 1

            need[s[r]] -= 1 #更改26个字母的匹配情况

            while counter == 0: #窗口字符串完全包含t，准备从左边缩小窗口
                if min_len > r - l + 1: #输出最小窗口
                    min_len = r - l + 1
                    res = s[l: r + 1]

                if need[s[l]] == 0: #counter = 0情况下，s[l]可能会是负数表示还有空余字符，s[l]=0表示刚刚好
                    counter += 1
                    
                need[s[l]] += 1
                l += 1

            r += 1 #窗口向右增大

        return res
```

注意：

```python
if need[s[r]] > 0: # 表示匹配上了t中的字符
                counter -= 1

            need[s[r]] -= 1 #更改26个字母的匹配情况
```

```python
if need[s[l]] == 0: #counter = 0情况下，s[l]可能会是负数表示还有空余字符，s[l]=0表示刚刚好
                    counter += 1
                    
                need[s[l]] += 1
                l += 1
```



### ✅[字符串的排列 x](https://leetcode-cn.com/problems/permutation-in-string/)

只维护s1大小的窗口

```python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        need = defaultdict(int)

        for i in s1:
            need[i] += 1

        l, r = 0, len(s1) - 1

        while r < len(s2):
            counter = Counter(s2[l:r+1])

            if need == counter:
                return True

            l += 1
            r += 1
        
        return False
```



### ✅[找到字符串中所有字母异位词 x](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

```Python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        need = defaultdict(int)

        for c in p:
            need[c] += 1
        
        l, r = 0, len(p) - 1
        res = []
        
        while r < len(s):
            counter = Counter(s[l:r + 1])
            if counter == need:
                res.append(l)
            
            l += 1
            r += 1 

        return res
```



### ✅[无重复字符的最长子串 x](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

[剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

```Python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        
        last_idx = {}
        
        l, max_length = 0, 0
        for r, c in enumerate(s):
            if c in last_idx and last_idx[c] >= l:
                max_length = max(max_length, r - l)
                l = last_idx[c] + 1
            last_idx[c] = r
        
        return max(max_length, len(s) - l) # note that the last substring is not judged in the loop
```



## 总结

- 和双指针题目类似，更像双指针的升级版，滑动窗口核心点是维护一个窗口集，根据窗口集来进行处理
- 核心步骤:
  - right 右移
  - 求结果
  - 收缩:left 右移
