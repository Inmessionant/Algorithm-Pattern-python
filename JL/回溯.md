# 回溯



回溯法（backtrack）常用于遍历列表所有子集，是 DFS 深度搜索一种，一般用于全排列，穷尽所有可能，遍历的过程实际上是一个决策树的遍历过程。时间复杂度一般 O(N!)，它不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高



组合 ，切割， 排列， 子集，棋盘



**回溯法解决的问题都可以抽象为树形结构（n叉树）**

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**



如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，**「那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！」**



![回溯算法理论基础](https://camo.githubusercontent.com/f65ca647f31913496481cd1aff144040bd7ee4f6bc30accd370bc78b4b265d13/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303133303137333633313137342e706e67)

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



## 模板

```go
result = []
func backtrack(选择列表,路径):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        做选择
        backtrack(选择列表,路径)
        撤销选择
```

核心就是从选择列表里做一个选择，然后一直递归往下搜索答案，如果遇到路径不通，就返回来撤销这次选择。

回溯算法关键在于:不合适就退回上一步



## 子集问题



### ✅[子集 x](https://leetcode-cn.com/problems/subsets/)

遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合

```Python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        
        n = len(nums)
        result = []
        
        def backtrack(start, k, route=[]):
            if len(route) == k: # 终止条件
                result.append(route.copy())
                return
            
            for i in range(start, :n):
                route.append(nums[i])
                backtrack(i + 1, k)
                route.pop() # 回溯操作

            return
        
        for k in range(n + 1):
            backtrack(0, k)
        
        return result
```

用子集II思路也能做，即：用的组合思路，将包含0，1，2，.. len(nums)分开处理，但是要注意去重，第一个开始为2处理过之后，第二个开始为2的组合肯定有重复，所以需要判断一下

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:

        nums = sorted(nums)
        result = []

        def backtrack(start, k, path):
            if len(path) == k and path not in result:
                result.append(path[:])
                return 
            for i in range(start, len(nums)):
                path.append(nums[i])
                backtrack(i + 1, k, path)
                path.pop()
        
        for k in range(len(nums) + 1):
            backtrack(0, k, [])

        return result
```



### ✅[子集 II x](https://leetcode-cn.com/problems/subsets-ii/)

用的组合思路，将包含0，1，2，.. len(nums)分开处理，但是要注意去重，第一个开始为2处理过之后，第二个开始为2的组合肯定有重复，所以需要判断一下

```Python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:

        nums = sorted(nums)
        result = []

        def backtrack(start, k, path):
            if len(path) == k and path not in result: //可能会有重复需要去重
                result.append(path[:])
                return 
            for i in range(start, len(nums)):
                path.append(nums[i])
                backtrack(i + 1, k, path)
                path.pop()
        
        for k in range(len(nums) + 1):
            backtrack(0, k, [])

        return result
```



------

## 组合问题



### ✅[组合 x](https://leetcode-cn.com/problems/combinations/)

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        result = []
        nums = sorted(nums)

        def backtrack(start, path):
            result.append(path[:])

            if start >= len(nums): return

            for i in range(start, len(nums)):
                path.append(nums[i])
                backtrack(i + 1, path)
                path.pop()

        backtrack(0, [])
        return result
```



**剪枝**

- 已经选择的元素个数：len(path);
- 还需要的元素个数为: k - len(path);
- 在集合n中至多要从该起始位置 : n - (k - len(path)) + 1，开始遍历,因为range是左闭右开，所以是n - (k - len(path)) + 2

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:

        res = []

        def  backtrack(start, n, k, path):
            if len(path) == k:
                res.append(path[:])
                return 
            for i in range(start, n - k + len(path) + 2):
                path.append(i)
                backtrack(i + 1, n, k, path)
                path.pop()

        
        backtrack(1, n, k, [])
        return res
```



### ✅[组合总和 III x](https://leetcode-cn.com/problems/combination-sum-iii/)

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        result = []

        def backtrack(start, path, sumpath):
            if sumpath > n: return 
            if len(path) == k and sumpath == n:
                result.append(path[:])
                return 
            for i in range(start, 10):
                path.append(i)
                sumpath += i
                backtrack(i + 1, path, sumpath)
                sumpath -= path.pop()

        backtrack(1, [], 0)
        return result 
```



### ✅[组合总和 x](https://leetcode-cn.com/problems/combination-sum/)

```Python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:

        result = []

        def backtrack(start, sumpath, path):
            if sumpath == target:
                result.append(path[:])
                return 
            if sumpath > target:
                return 
            for i in range(start, len(candidates)):
                path.append(candidates[i])
                sumpath += candidates[i]
                backtrack(i, sumpath, path) // candidates 中的数字可以无限制重复被选取
                sumpath -= path.pop()
        
        backtrack(0, 0, [])
        return result
```



### [全排列](https://leetcode-cn.com/problems/permutations/)

```Python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        
        n = len(nums)
        result = []
        
        in_route = [False] * n
        
        def backtrack(route=[]):
            
            if len(route) == n:
                result.append(route.copy())
                return
                
            for i in range(n):
                if not in_route[i]:
                    route.append(nums[i])
                    in_route[i] = True
                    backtrack()
                    route.pop()
                    in_route[i] = False
            
            return
        
        backtrack()
        return result
```

- 思路 2: 针对此题的更高级的回溯，利用原有的数组，每次回溯将新选择的元素与当前位置元素交换，回溯完成再换回来

```Python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        
        n = len(nums)
        result = []
        
        def backtrack(idx=0):
            if idx == n:
                result.append(nums.copy())
            for i in range(idx, n):
                nums[idx], nums[i] = nums[i], nums[idx]
                backtrack(idx + 1)
                nums[idx], nums[i] = nums[i], nums[idx]
            return

        backtrack()
        return result
```



### [全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

```Python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        
        nums = sorted(nums)
        n = len(nums)
        result = []
        
        in_route = [False] * n
        
        def backtrack(route=[]):
            
            if len(route) == n:
                result.append(route.copy())
                return
            
            last = None
            for i in range(n):
                if not in_route[i] and nums[i] != last:
                    route.append(nums[i])
                    in_route[i] = True
                    backtrack()
                    last = route.pop()
                    in_route[i] = False
            
            return
        
        backtrack()
        return result
```



### [电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```Python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        
        n = len(digits)
        result = []
        
        if n == 0:
            return result
        
        num2char = {
            '2': ['a', 'b', 'c'],
            '3': ['d', 'e', 'f'],
            '4': ['g', 'h', 'i'],
            '5': ['j', 'k', 'l'],
            '6': ['m', 'n', 'o'],
            '7': ['p', 'q', 'r', 's'],
            '8': ['t', 'u', 'v'],
            '9': ['w', 'x', 'y', 'z']
        }
        
        def backtrack(idx=0, route=[]):
            if idx == n:
                result.append(''.join(route))
                return
            
            for c in num2char[digits[idx]]:
                route.append(c)
                backtrack(idx + 1, route)
                route.pop()
            
            return
        
        backtrack()
        return result
```



### [分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

```Python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        
        N = len(s)
        Pal = collections.defaultdict(set)
        
        def isPal(i, j):
            if i < j:
                return j in Pal[i]
            return True
        
        for j in range(N):
            for i in range(j + 1):
                if s[i] == s[j] and isPal(i + 1, j - 1):
                    Pal[i].add(j)
        
        result = []
        
        def backtrack(first=0, route=[]):

            if first == N:
                result.append(route[:])
                return

            for i in Pal[first]:
                route.append(s[first:i+1])
                backtrack(i + 1)
                route.pop()
            
            return
        
        backtrack()
        return result
```



### [复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

```Python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        
        n = len(s)
        result = []
        
        if n > 12:
            return result
        
        def Valid_s(i, j):
            return i < j and j <= n and ((s[i] != '0' and int(s[i:j]) < 256) or (s[i] == '0' and i == j - 1))
        
        def backtrack(start=0, route=[]):
            
            if len(route) == 3:
                if Valid_s(start, n):
                    result.append('.'.join(route) + '.' + s[start:])
                return
            
            for i in range(start, start + 3):
                if Valid_s(start, i + 1):
                    route.append(s[start:i + 1])
                    backtrack(i + 1, route)
                    route.pop()
                
            return
        
        backtrack()
        return result
```

