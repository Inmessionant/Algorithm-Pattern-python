# 动态规划



动态规划就是**把大问题变成小问题**，并**解决了小问题重复计算**的方法称为动态规划



**解题步骤：**

- 确定dp数组（dp table）以及下标的含义

- 确定递推公式

- dp数组如何初始化

- 确定遍历顺序

- 举例推导dp数组

  

------



- 从暴力规划中来
- 将每一个子问题的解记录下来，避免重复计算
- 把暴力递归的过程，抽象成了状态表达
- 并且存在化简状态表达，使其更加简洁的可能



**递归和动规关系**

**递归是一种程序的实现方式：函数的自我调用**

```go
Function(x) {
	...
	Funciton(x-1);
	...
}
```

**动态规划：是一种解决问题的思想**，大规模问题的结果，是由小规模问题的结果运算得来的。**动态规划可用递归来实现**



**动态规划和 DFS 区别**

- 二叉树子问题是没有交集，所以大部分二叉树都用递归或者分治法，即 DFS
- 像 [triangle](https://leetcode-cn.com/problems/triangle/) 这种是有重复走的情况，**子问题是有交集**，所以可以用动态规划



------



## 矩阵



### ✅[最小路径和 x](https://leetcode-cn.com/problems/minimum-path-sum/)

```Python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:

        if not grid: return 0

        for j in range(1, len(grid[0])):
            grid[0][j] = grid[0][j-1] + grid[0][j]
        for i in range(1, len(grid)):
            grid[i][0] = grid[i-1][0] + grid[i][0]
        
        for i in range(1, len(grid)):
            for j in range(1, len(grid[0])):
                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]
        
        return grid[-1][-1]
```

空间复杂度可以优化，例如每次只存储上一行的 $dp$ 值，则可以将空间复杂度优化到 O(n)*O*(*n*)。



### ✅[不同路径 x](https://leetcode-cn.com/problems/unique-paths/)

- 注意题目中说机器人每次只向下或者向右移动一步，那么其实**机器人走过的路径可以抽象为一颗二叉树，而叶子节点就是终点！**![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6swmiaLRIjBO9gUN4RfMTfFeGjAcICTXoABd6LRk0MnNPvgMVTzKwQrrR8SDTPWxBIPCvwCTzPlZQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)能



- 动态规划

```Python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 1.dp[i][j]表示从(0,0)出发,到达(i,j)有dp[i][j]条不同的路径
        dp = [[0 for _ in range(n)] for _ in range(m)]
        # 3.dp数组初始化，dp[0][i], dp[i][0]都是1
        for i in range(n): dp[0][i] = 1
        for i in range(m): dp[i][0] = 1

        # 4.从左上到右下的遍历顺序
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1] # 2.dp[i][j]只有左边和上边两条方向进入
        
        return dp[-1][-1]
```



### ✅[不同路径 II x](https://leetcode-cn.com/problems/unique-paths-ii/)

```Python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if obstacleGrid[0][0] == 1: return 0  # 左上角开始位置有障碍物
        # 1.dp[i][j] 表示从(0,0)出发到(i,j)位置有多少条不同的路径
        dp = [[0 for _ in range(len(obstacleGrid[0]))] for _ in range(len(obstacleGrid))]
        # 3.dp数组初始化，只有没有障碍物才是1，一旦遇到有障碍物，这个位置及以后都是0
        for i in range(len(obstacleGrid[0])):
            if obstacleGrid[0][i] == 0:
                dp[0][i] = 1
            else:
                break
        # 4.确定遍历顺序，从左上到右下
        for i in range(len(obstacleGrid)):
            if obstacleGrid[i][0] == 0:
                dp[i][0] = 1
            else:
                break
        for i in range(1, len(obstacleGrid)):
            for j in range(1, len(obstacleGrid[0])):
                if obstacleGrid[i][j] == 0:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1] # 2.递推公式，但是要保证没有障碍物，有障碍物这个位置dp[i][j]=0
        
        return dp[-1][-1]
```

我们可以运用「滚动数组思想」把空间复杂度优化称 O(m)O(m)。「滚动数组思想」是一种常见的动态规划优化方法，在我们的题目中已经多次使用到，例如「剑指 Offer 46. 把数字翻译成字符串」、「70. 爬楼梯」等，当我们定义的状态在动态规划的转移方程中只和某几个状态相关的时候，就可以考虑这种优化方法，目的是给空间复杂度「降维」。



### ✅[三角形最小路径和 x](https://leetcode-cn.com/problems/triangle/)

```
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:  # Bottom -> Up
        if len(triangle) == 0:
            return 0
        
        dp = triangle[-1].copy()
        
        for i in range(-2, -len(triangle) - 1, -1):
            for j in range(len(triangle[i])):
                dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])
        
        return dp[0]
```



## 基础



### ✅[斐波那契数 x](https://leetcode-cn.com/problems/fibonacci-number/)

可以用递归，也可以用动态规划

```python
class Solution:
    def fib(self, n: int) -> int:
        if n < 2: return n
        # 1.d[i]表示第i个斐波那契数
        dp = [0 for _ in range(n+1)] 
        dp[0], dp[1] = 0, 1  # 3.初始化
        for i in range(2, n+1): # 4.确定遍历顺序
            dp[i] = dp[i-1] + dp[i-2] # 2.递推公式
        return dp[n]
```

滚动数组（空间优化）

```Python
class Solution:
    def fib(self, n: int) -> int:
        if n < 2: return n
        k = 2
        # base case
        res = [0, 1]
        # 状态转移
        while k <= n:
            res[0], res[1] = res[1], res[0] + res[1]
            k += 1
        return res[1]
```





### ✅[爬楼梯 x](https://leetcode-cn.com/problems/climbing-stairs/)

```Python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2: return n

        # 1.dp[i]表示爬到第i层阶梯的方法数
        dp = [0 for _ in range(n+1)]
        dp[1], dp[2] = 1, 2 # 3. dp数组初始化（n是正整数，不用管n=0）

        for i in range(3, n+1): # 4. 确定遍历顺序
            dp[i] = dp[i-1] + dp[i-2] # 2.爬到第i层方法数 = 爬到第i-1层的方法数（最后一步爬1个台阶） + 爬到第i-2层的方法数（最后一步爬2个台阶）
        
        return dp[n]
```



### ✅[使用最小花费爬楼梯 x](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        # 1.dp定义：第i个台阶所花费的最小体力为dp[i]
        dp = [0 for _ in range(len(cost))]
        dp[0], dp[1] = cost[0], cost[1]  # 3.初始化0, 1阶梯dp=cost

        for i in range(2, len(cost)): # 4.确定遍历顺序
            dp[i] = min(dp[i-1], dp[i-2]) + cost[i]  # 2.dp[i]是由 min(dp[i-1], dp[i-2])，然后加上爬上i阶花费的cost[i]
        
        return min(dp[-1], dp[-2]) # 到达楼顶可以看作是Min(倒数第一个阶梯，倒数第二个阶梯)，然后再加上楼顶的cost=0得到       
```



### ✅[整数拆分 x](https://leetcode-cn.com/problems/integer-break/)

https://mp.weixin.qq.com/s/cVbyHrsWH_Rfzlj-ESr01A

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        # 1. dp[i]表示分拆数字i，得到的最大乘积
        dp = [float("-inf") for _ in range(n+1)]
        dp[2] = 1 # 3.dp初始化
        for i in range(3, n+1):  # 遍历顺序
            for j in range(i):
                dp[i] = max(dp[i], j * (i - j), j * dp[i - j]) # 2. 递推公式
        
        return dp[n]
```



### ✅[最大子序和 x](https://leetcode-cn.com/problems/maximum-subarray/)

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        for i in range(1, len(nums)):
            nums[i] = max(nums[i-1] + nums[i], nums[i])
        return max(nums)
```



## 子序列



### ✅[最长递增子序列 x](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

不是最长连续递增子序列，找到其中**最长严格递增子序列**的长度

```Python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums: return 0
        dp = [1 for _ in range(len(nums))]  # 1.dp[i]表示i之前包括i的最长上升子序列  3.dp初始化
        for i in range(len(nums)):  #4.确定遍历顺序
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)  # 2.递推公式
        return max(dp)
```



### [✅最长连续递增序列 x](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

```python
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        if len(nums) == 0: return 0
        # 3.dp数组初始化,以下标i为结尾的数组的连续递增的子序列长度最少也应该是1
        dp = [1 for _ in range(len(nums))]  # 1.dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i],注意这里的定义，一定是以下标i为结尾，并不是说一定以下标0为起始位置

        # 4.遍历顺序
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                dp[i] = dp[i - 1] + 1  # 2.递推公式,因为本题要求连续递增子序列，所以就必要比较nums[i + 1]与nums[i]，而不用去比较nums[j]与nums[i] （j是在0到i之间遍历）

        return max(dp)
```



### ✅[最长重复子数组 x](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

注意题目中说的子数组，其实就是连续子序列

```python
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:

        m, n = len(nums1), len(nums2)
        # 1.dp[i][j] ：以下标i - 1为结尾的num1，和以下标j - 1为结尾的num2，最长重复子数组长度为dp[i][j]
        # 3.dp数组初始化:
        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
        
        res = 0
        # 4.遍历顺序:遍历i 和 j 要从1开始,同时题目要求长度最长的子数组的长度。所以在遍历的时候顺便把dp[i][j]的最大值记录下来
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if nums1[i - 1] == nums2[j - 1]:  # 2.递推公式
                    dp[i][j] = dp[i - 1][j - 1] + 1
                res = max(res, dp[i][j])
        
        return res
```

空间优化，**滚动数组**

```python
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        m, n = len(nums1), len(nums2)
        dp = [0 for _ in range(n + 1)]
        res = 0

        for i in range(1, m + 1):
            for j in range(n, 0, -1):
                if nums1[i - 1] == nums2[j - 1]:
                    dp[j] = dp[j -1] + 1
                else: 
                    dp[j] = 0
                res = max(res, dp[j])

        return res
```



### ✅[最长公共子序列 x](https://leetcode-cn.com/problems/longest-common-subsequence/)

之所以` dp[i][j] `的定义不是` text1[0:i] `和` text2[0:j] `，是为了方便当` i = 0 `或者` j = 0 `的时候，`dp[i][j]`表示的为空字符串和另外一个字符串的匹配，这样 `dp[i][j] `可以初始化为 0.

- 当 text1[i - 1] == text2[j - 1] 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 1，所以 dp[i][j] = dp[i - 1][j - 1] + 1；举个例子，比如对于 ac 和 bc 而言，他们的最长公共子序列的长度等于 a 和 b 的最长公共子序列长度 0 + 1 = 1；
- 当 text1[i - 1] != text2[j - 1] 时，说明两个子字符串的最后一位不相等，那么此时的状态 dp[i][j] 应该是 dp[i - 1][j] 和 dp[i][j - 1] 的最大值。举个例子，比如对于 ace 和 bc 而言，他们的最长公共子序列的长度等于 ① ace 和 b 的最长公共子序列长度0 与 ② ac 和 bc 的最长公共子序列长度1 的最大值，即 1；

```Python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        # 1.dp[i][j] ：以下标i - 1为结尾的text1，和以下标j - 1为结尾的text2，最长重复子数组长度为dp[i][j]
        # 3.dp数组初始化：当 i = 0 时，dp[0][j] 表示的是 text1 中取空字符串 跟 text2 的最长公共子序列，结果肯定为 0；当 j = 0 时，dp[i][0] 表示的是 text2 中取空字符串 跟 text1 的最长公共子序列，结果肯定为 0.
        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
		# 4.确定遍历顺序(从1开始，表示以下标0为结尾的text1和text2)
        for i in range(1, m + 1):
            for j in range(1, n + 1): 
                if text1[i - 1] == text2[j - 1]: # 2.递推公式
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        
        return dp[-1][-1]
```



### [编辑距离](https://leetcode-cn.com/problems/edit-distance/)

思路：和上题很类似，相等则不需要操作，否则取删除、插入、替换最小操作次数的值+1

```Python
class Solution:
    def minDistance(self, w1: str, w2: str) -> int:
        
        if w1 == '': return len(w2)
        if w2 == '': return len(w1)
        
        m, n = len(w1), len(w2)
        if m < n:
            w1, w2, m, n = w2, w1, n, m
        
        dp = [int(w1[0] != w2[0])] * n
        dp_new = [0] * n
        
        for j in range(1, n):
            dp[j] = dp[j - 1] + int(w2[j] != w1[0] or dp[j - 1] != j)
        
        for i in range(1, m):
            dp_new[0] = dp[0] + int(w2[0] != w1[i] or dp[0] != i)
            
            for j in range(1, n):
                dp_new[j] = min(dp[j - 1] + int(w2[j] != w1[i]), dp[j] + 1, dp_new[j - 1] + 1)
                
            dp, dp_new = dp_new, dp
        
        
        return dp[-1]
```





## 01 背包



https://mp.weixin.qq.com/s/FwIiPPmR18_AJO5eiidT6w



- 题库也告诉我们，**01背包和完全背包**就够用了；
- 而完全背包又是也是01背包稍作变化而来，即：完全背包的物品数量是无限的；
- **背包问题的理论基础重中之重是01背包，一定要理解透！**



背包问题的暴力解法：每一件物品其实只有两个状态，取或者不取，所以可以使用**回溯法**搜索出所有的情况，那么时间复杂度就是O(2^n)，这里的n表示物品数量；



![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6xPu8BiaJQNCasvLUeXpIGBffZQW7TxLmyfMAg0HaxVSex3FPkWh3ic88SRTXFlvz3XnVpdicWWlzYA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷；**这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了**



### ✅[背包问题-ii x](https://www.lintcode.com/problem/backpack-ii/description)

**`dp(i, j) `为前 i 个物品，装入` j `背包的最大价值**



- 二维dp数组01背包

```python
class Solution:
    def backpack(self, weight, value, bagweight):
        dp = [[0 for _ in range(bagweight + 1)] for _ in range(len(weight))]

        for j in range(bagweight, weight[0] - 1, -1):
            dp[0][j] = dp[0][j - weight[0]] + value[0]

        for i in range(len(weight)):
            for j in range(bagweight + 1):
                if j < weight[i]:
                    dp[i][j] = dp[i - 1][j]
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
        return dp[-1][-1]


weight = [2, 3, 8]
value = [2, 5, 8]
bagweight = 10
solutin = Solution()
res = solutin.backpack(weight, value, bagweight)
print(res)
```



- 一维dp数组（滚动数组）

```python
class Solution:
    def backpack2(self, weight, value, bagweight):
        dp = [0 for _ in range(bagweight + 1)]
        
        # 一维dp遍历的时候，背包是从大到小，倒叙遍历是为了保证物品i只被放入一次！
        for i in range(len(weight)):
            for j in range(bagweight, weight[i]-1, -1):
                dp[j] = max(dp[j], dp[j-weight[i]] + value[i])

        return dp[-1]
```

举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15

如果正序遍历

dp[1] = dp[1 - weight[0]] + value[0] = 15

dp[2] = dp[2 - weight[0]] + value[0] = 30

此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。

为什么倒叙遍历，就可以保证物品只放入一次呢？

倒叙就是先算dp[2]

dp[2] = dp[2 - weight[0]] + value[0] = 15  （dp数组已经都初始化为0）

dp[1] = dp[1 - weight[0]] + value[0] = 15

所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了

**为什么二维dp数组历的时候不用倒叙呢？**

`因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！



### ✅[分割等和子集 x](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

**0-1背包：只要找到集合里能够出现 sum / 2 的子集总和，就算是可以分割成两个相同元素和子集了**

- 背包的体积为sum / 2
- 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值
- 背包如何正好装满，说明找到了总和为 sum / 2 的子集。
- 背包中每一个元素是不可重复放入。

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:  
        # 本题相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]
        if sum(nums) % 2 == 1:  return False
        target = sum(nums) // 2
        # 1.dp[i]表示背包总容量为i，最大可以凑齐i的子集总和为dp[i]
        dp = [0 for _ in range(target+1)]  # 3.dp初始化

        # 4.确定遍历顺序:如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒叙遍历
        for i in range(len(nums)):
            for j in range(target, nums[i] - 1, -1):
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])  # 2.递推公式
        
        if dp[-1] == target:  return True   # 如果dp[i] == i 说明，集合中的子集总和正好可以凑成总和i
        return False
```

**回溯(res存放和为target子集)**

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        if sum(nums) % 2 == 1:  return False
        target = sum(nums) // 2
        res = []

        def backpack(start, path, sumpath, target, nums):
            if sumpath > target or start > len(nums):  return 
            if sumpath == target:
                res.append(path[:])
                return
            for i in range(start, len(nums)):
                path.append(nums[i])
                sumpath += nums[i]
                backpack(i + 1, path, sumpath, target, nums)
                sumpath -= path.pop()
            
        
        backpack(0, [], 0, target, nums)
        return True if res else False
```



### ✅[最后一块石头的重量 II x](https://leetcode-cn.com/problems/last-stone-weight-ii/)

**尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，**这样就化解成01背包问题了，和**分割等和子集**非常像

```python
class Solution:
    def lastStoneWeightII(self, stones: List[int]) -> int:
        sumstones = sum(stones)
        target = sumstones // 2
        # 1.dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背dp[j]这么重的石头
        dp = [0 for _ in range(target + 1)]  # 3.dp数组初始化

        for i in range(len(stones)):  # 4.遍历顺序
            for j in range(target, stones[i] - 1, -1):
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])  # 2.递推公式
        
        return abs((sumstones - dp[-1]) - dp[-1]) # (sumstones - dp[-1])表示另外一堆石头重量和
```



### [✅目标和 x](https://leetcode-cn.com/problems/target-sum/)

**这次和之前遇到的背包问题不一样了，之前都是求容量为j的背包，最多能装多少；本题则是装满有几种方法，其实这就是一个组合问题了；**

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        # +(left) - (right) = target
        # left + right = sum
        # left = (sum + target) // 2

        sumNums = sum(nums)
        if sumNums < target: return 0
        if (sumNums + target) % 2 == 1: return 0
        bagSize = (sumNums + target) // 2
        
        # 1.dp[j] 表示：填满j（包括j）这么大容积的包，有dp[i]种方法
        # 3.dp数组初始化,dp[0] = 1，装满容量为0的背包，有1种方法，就是装0件物品
        dp = [0 for _ in range(bagSize + 1)]
        dp[0] = 1
        # 4.确定遍历顺序:对于01背包问题一维dp的遍历，nums放在外循环，target在内循环，且内循环倒序
        for i in range(len(nums)):
            for j in range(bagSize, nums[i] - 1, -1):
                dp[j] += dp[j - nums[i]]  # 2.递推公式:不考虑nums[i]的情况下，填满容量为j - nums[i]的背包，有dp[j - nums[i]]中方法,那么只要搞到nums[i]的话，凑成dp[j]就有dp[j - nums[i]]种方法
        return dp[-1]
```



### ✅[ 一和零 x](https://leetcode-cn.com/problems/ones-and-zeroes/)

https://github.com/Inmessionant/leetcode-master/blob/master/problems/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.md

**strs 数组里的元素就是物品，每个物品都是一个！而m 和 n相当于是一个背包，两个维度的背包**

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        if not strs or m < 0 or n < 0: return 0 
        # 3.dp数组初始化
        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]  # 1.dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]
        #4.确定遍历顺序
        for st in strs:
            count = collections.Counter(st)
            num0, num1 = count['0'], count['1']

            for i in range(m, num0 - 1, -1):
                for j in range(n, num1 - 1, -1):
                    dp[i][j] = max(dp[i][j], dp[i - num0][j - num1] + 1)  # 2.dp[i][j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1,dp[i][j] 就可以是 dp[i - zeroNum][j - oneNum] + 1
        
        return dp[-1][-1]
```



## 完全背包



**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**

**代码中01背包和完全背包唯一不同就是体现在遍历顺序上**：



回顾一下01背包的核心代码：

```c++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次；而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：

```c++
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j < bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```



01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一位dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量；

**在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓！**

因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的，只要保证下标j之前的dp[j]都是经过计算的就可以了；



### [✅零钱兑换 x](https://leetcode-cn.com/problems/coin-change/)

```Python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # 1.dp[j]代表含义：填满容量为j的背包最少需要多少硬币
        # 3.dp初始化，判断最小需要多少硬币，初始化为“inf”，dp[0]=0表示装满0最少需要0个硬币
        dp = [float("inf") for _ in range(amount + 1)]
        dp[0] = 0

        # 4.遍历顺序：完全背包的物品是可以添加多次的，所以两重循环要从小到大去遍历
        for i in range(len(coins)):
            for j in range(coins[i], amount + 1):
                dp[j] = min(dp[j], dp[j - coins[i]] + 1) # 2.转移方程
        
        return dp[-1] if dp[-1] != float("inf") else -1

```



### ✅[零钱兑换 II x](https://leetcode-cn.com/problems/coin-change-2/)

本题和纯完全背包不一样，**纯完全背包是能否凑成总金额，而本题是要求凑成总金额的组合数(组合不强调元素之间的顺序，排列强调元素之间的顺序)**

**求装满背包有几种方法，一般公式都是：dp[j] += dp[j - nums[i]]**



```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        # 1.dp[j]：凑成总金额j的货币组合数为dp[j]
        dp = [0 for _ in range(amount + 1)]
        dp[0] = 1

        for i in range(len(coins)):
            for j in range(coins[i], amount + 1):
                dp[j] += dp[j - coins[i]] # 2.递推公式
        
        return dp[-1]
```



因为纯完全背包求得是能否凑成总和，和凑成总和的元素有没有顺序没关系，而**本题要求凑成总和的组合数，元素之间要求没有顺序**。

那么本题两个for循环的先后顺序可就有说法了：

我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况；

```c++
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}
```

假设：coins[0] = 1，coins[1] = 5。

那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况；

**所以这种遍历顺序中dp[j]里计算的是组合数！**

如果把两个for交换顺序：

```c++
for (int j = 0; j <= amount; j++) { // 遍历背包容量
    for (int i = 0; i < coins.size(); i++) { // 遍历物品
        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
    }
}
```

背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。

**此时dp[j]里算出来的就是排列数！**



### ✅[组合总和 Ⅳ x](https://leetcode-cn.com/problems/combination-sum-iv/)

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        # 1.dp[i]: 凑成目标正整数为i的排列个数为dp[i]
        dp = [0 for _ in range(target + 1)]
        dp[0] = 1  # 3.dp数组初始化:装满0的背包有1种方法
        # 4.遍历顺序
        # 如果求组合数就是外层for循环遍历物品，内层for遍历背包。如果求排列数就是外层for遍历背包，内层for循环遍历物品。
        for i in range(target + 1):
            for j in range(len(nums)):
                if i - nums[j] >= 0:
                    dp[i] += dp[i - nums[j]]  # 2.求装满背包有几种方法，递推公式一般都是dp[i] += dp[i - nums[j]];
        
        return dp[-1]
```



### [单词拆分](https://leetcode-cn.com/problems/word-break/)

核心是dp[i]=True表示s前i-1个能用worddict表示，s[i, j+1]在worddict里面，说明dp[j] = True

```Python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:       
        n=len(s)
        dp=[False]*(n+1)
        dp[0]=True
        for i in range(n):
            for j in range(i+1,n+1):
                if(dp[i] and (s[i:j] in wordDict)):
                    dp[j]=True
        return dp[-1]
```



### [单词拆分 II](https://leetcode-cn.com/problems/word-break-ii/)

思路：此题 DP 解法容易想但并不是好做法，因为和 word-break 不同，此题需要返回所有可行分割而不是找到一组就可以。这里使用 个人推荐 backtrack with memoization

```Python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        
        n = len(s)
        result = []
        mem = collections.defaultdict(list)
        wordDict = set(wordDict)
        
        def backtrack(first=0, route=[]):
            if first == n:
                result.append(' '.join(route))
                return True
            
            if first not in mem:
                for next_first in range(first + 1, n + 1):
                    if s[first:next_first] in wordDict:
                        route.append(s[first:next_first])
                        if backtrack(next_first, route):
                            mem[first].append(next_first)
                        route.pop()
                if len(mem[first]) > 0:
                    return True
            elif len(mem[first]) > 0:
                for next_first in mem[first]:
                    route.append(s[first:next_first])
                    backtrack(next_first)
                    route.pop()
                return True
            
            return False
        
        backtrack()
        return result
```



## 股票



### ✅[买卖股票的最佳时机 x](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

- 贪心

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        res, low = 0, float("inf")

        for price in prices:
            low = min(low, price)
            res = max(res, price - low)
        
        return res
```

- 动态规划

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 1.dp[i][0] 表示第i天持有股票所得最多现金, dp[i][1] 表示第i天不持有股票所得最多现金
        # 3.dp数组初始化
        dp = [[0 for _ in range(2)] for _ in range(len(prices))]
        dp[0][0], dp[0][1] = -prices[0], 0
        # 4.遍历顺序
        for i in range(1, len(prices)):
            # 2.递推公式
            dp[i][0] = max(dp[i - 1][0], -prices[i])
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])

        return dp[-1][1]
```



### [✅买卖股票的最佳时机 II x](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

- 贪心

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        res = 0
        for i in range(1, len(prices)):
            res += max(0, prices[i] - prices[i - 1])
        return res
```

- 动态规划

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 1.dp[i][0] 表示第i天持有股票所得现金,dp[i][1] 表示第i天不持有股票所得最多现金
        # 3.dp数组初始化
        dp = [[0 for _ in range(2)] for _ in range(len(prices))]
        dp[0][0], dp[0][1] = -prices[0], 0 
        # 4.遍历顺序
        for i in range(1, len(prices)):
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]) # 2.递推公式，注意这里是和121. 买卖股票的最佳时机唯一不同的地方
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])
        
        return dp[-1][1]
```



### ✅[买卖股票的最佳时机 III x](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 1.dp数组以及下标的含义:一天一共就有五个状态， 0. 没有操作 1.第一次买入 2.第一次卖出 3.第二次买入 4.第二次卖出 dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金
        # 3.dp数组初始化
        dp = [[0 for _ in range(5)] for _ in range(len(prices))]
        dp[0][1], dp[0][3] = -prices[0], -prices[0]
        # 4.遍历顺序
        for i in range(1, len(prices)):
            # 2.递推公式
            dp[i][0] = dp[i - 1][0]
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]) # dp[i][1]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i])
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i])
        
        return dp[-1][-1]
```



### ✅[买卖股票的最佳时机 IV x](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        m, n = len(prices), 2 * k + 1
        if m == 0: return 0
        # 确定dp数组以及下标的含义：使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]，j的状态表示为：0 表示不操作 1 第一次买入 2 第一次卖出 3 第二次买入 4 第二次卖出 ..... 除了0以外，偶数就是卖出，奇数就是买入状态，题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了
        dp = [[0 for _ in range(n)] for _ in range(m)]
        # 3.dp数组初始化：第0天没有操作，这个最容易想到，就是0，即：dp[0][0] = 0;第0天做第一次买入的操作，dp[0][1] = -prices[0];第0天做第一次卖出的操作，dp[0][2] = 0;所以同理可以推出dp[0][j]当j为奇数的时候都初始化为 -prices[0]
        for j in range(1, 2 * k, 2):
            dp[0][j] = -prices[0]
        # 4.遍历顺序
        for i in range(1, m):
            for j in range(0, 2 * k - 1, 2):
                # 2.递推公式
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]) # dp[i][1]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票
                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])
        
        return dp[-1][-1]
```



### [最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

经典的维特比译码类问题，找到状态空间和状态转移关系即可

```Python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        buy, buy_then_nothing, sell, sell_then_nothing = float('-inf'), float('-inf'), float('-inf'), 0
        
        for p in prices:
            buy, buy_then_nothing, sell, sell_then_nothing = sell_then_nothing - p, max(buy, buy_then_nothing), max(buy, buy_then_nothing) + p, max(sell, sell_then_nothing)
        
        return max(buy, buy_then_nothing, sell, sell_then_nothing)
```





## 其他



### [乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

处理负数情况稍微有点复杂，注意需要同时 DP 正数乘积和负数乘积

```Python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        
        max_product = float('-inf')

        dp_pos, dp_neg = 0, 0
        
        for num in nums:
            if num > 0:
                dp_pos, dp_neg = max(num, num * dp_pos), dp_neg * num
            else:
                dp_pos, dp_neg = dp_neg * num, min(num, dp_pos * num)
            
            if dp_pos != 0:
                max_product = max(max_product, dp_pos)
            elif dp_neg != 0:
                max_product = max(max_product, dp_neg)
            else:
                max_product = max(max_product, 0)
            
        return max_product
```



### [解码方法](https://leetcode-cn.com/problems/decode-ways/)

常规 DP 题，注意处理edge case即可

```Python
class Solution:
    def numDecodings(self, s: str) -> int:
        
        def valid_2(i):
            if i < 1:
                return 0
            num = int(s[i-1:i+1])
            return int(num > 9 and num < 27)
        
        dp_1, dp_2 = 1, 0
        for i in range(len(s)):
            dp_1, dp_2 = dp_1 * int(s[i] != '0') + dp_2 * valid_2(i), dp_1
        
        return dp_1
```



### [戳气球](https://leetcode-cn.com/problems/burst-balloons/)

此题主要难点是构造 DP 的状态，过程为逆着气球戳爆的顺序

```Python
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        
        n = len(nums)
        nums.append(1)
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        
        for dist in range(2, n + 2):
            for left in range(-1, n - dist + 1):
                right = left + dist
                max_coin = float('-inf')
                left_right = nums[left] * nums[right]
                for j in range(left + 1, right):
                    max_coin = max(max_coin, left_right * nums[j] + dp[left][j] + dp[j][right])
                dp[left][right] = max_coin
        nums.pop()
        return dp[-1][n]
```

