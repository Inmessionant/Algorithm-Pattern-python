# 动态规划



- 确定dp数组（dp table）以及下标的含义

- 确定递推公式

- dp数组如何初始化

- 确定遍历顺序

- 举例推导dp数组

  

动态规划就是**把大问题变成小问题**，并**解决了小问题重复计算**的方法称为动态规划



## 递归和动规关系

**递归是一种程序的实现方式：函数的自我调用**

```go
Function(x) {
	...
	Funciton(x-1);
	...
}
```

**动态规划：是一种解决问题的思想**，大规模问题的结果，是由小规模问题的结果运算得来的。**动态规划可用递归来实现**



## 动态规划和 DFS 区别

- 二叉树子问题是没有交集，所以大部分二叉树都用递归或者分治法，即 DFS
- 像 [triangle](https://leetcode-cn.com/problems/triangle/) 这种是有重复走的情况，**子问题是有交集**，所以可以用动态规划



### ✅[triangle](https://leetcode-cn.com/problems/triangle/)



动态规划，自底向上

```Python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        if len(triangle) == 0:
            return 0
        
        dp = triangle[-1].copy()
        
        for i in range(-2, -len(triangle) - 1, -1):
            for j in range(len(triangle[i])):
                dp[j] = triangle[i][j] + min(dp[j], dp[j + 1])
        
        return dp[0]

```



动态规划，自顶向下

```Python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        if len(triangle) == 0:
            return 0
        
        dp = triangle[0]
        for row in triangle[1:]:
            dp_new = [row[0] + dp[0]]
            for i in range(len(dp) - 1):
                dp_new.append(row[i+1] + min(dp[i], dp[i+1]))
            dp_new.append(row[-1] + dp[-1])
            dp = dp_new
        
        return min(dp)
```



## 常见四种类型



## 矩阵



### ✅[minimum-path-sum](https://leetcode-cn.com/problems/minimum-path-sum/)



```Python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        if not grid: return 0

        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if i == 0 and j == 0: # （0，0）位置
                    grid[i][j] = grid[i][j]
                elif i == 0: # 最上面一行
                    grid[i][j] = grid[i][j-1] + grid[i][j]
                elif j == 0: #最左面一列
                    grid[i][j] = grid[i-1][j] + grid[i][j]
                else:
                    grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]
        
        return grid[-1][-1]
```

空间复杂度可以优化，例如每次只存储上一行的 $dp$ 值，则可以将空间复杂度优化到 O(n)*O*(*n*)。



### ✅[不同路径 x](https://leetcode-cn.com/problems/unique-paths/)

- 注意题目中说机器人每次只向下或者向右移动一步，那么其实**机器人走过的路径可以抽象为一颗二叉树，而叶子节点就是终点！**![图片](https://mmbiz.qpic.cn/mmbiz_png/ciaqDnJprwv6swmiaLRIjBO9gUN4RfMTfFeGjAcICTXoABd6LRk0MnNPvgMVTzKwQrrR8SDTPWxBIPCvwCTzPlZQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)能



- 动态规划

```Python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 1.dp[i][j]表示从(0,0)出发,到达(i,j)有dp[i][j]条不同的路径
        dp = [[0 for _ in range(n)] for _ in range(m)]
        # 3.dp数组初始化，dp[0][i], dp[i][0]都是1
        for i in range(n): dp[0][i] = 1
        for i in range(m): dp[i][0] = 1

        # 4.从左上到右下的遍历顺序
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1] # 2.dp[i][j]只有左边和上边两条方向进入
        
        return dp[-1][-1]
```



### ✅[不同路径 II x](https://leetcode-cn.com/problems/unique-paths-ii/)

```Python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        if obstacleGrid[0][0] == 1: return 0  # 左上角开始位置有障碍物
        # 1.dp[i][j] 表示从(0,0)出发到(i,j)位置有多少条不同的路径
        dp = [[0 for _ in range(len(obstacleGrid[0]))] for _ in range(len(obstacleGrid))]
        # 3.dp数组初始化，只有没有障碍物才是1，一旦遇到有障碍物，这个位置及以后都是0
        for i in range(len(obstacleGrid[0])):
            if obstacleGrid[0][i] == 0:
                dp[0][i] = 1
            else:
                break
        # 4.确定遍历顺序，从左上到右下
        for i in range(len(obstacleGrid)):
            if obstacleGrid[i][0] == 0:
                dp[i][0] = 1
            else:
                break
        for i in range(1, len(obstacleGrid)):
            for j in range(1, len(obstacleGrid[0])):
                if obstacleGrid[i][j] == 0:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1] # 2.递推公式，但是要保证没有障碍物，有障碍物这个位置dp[i][j]=0
        
        return dp[-1][-1]
```

我们可以运用「滚动数组思想」把空间复杂度优化称 O(m)O(m)。「滚动数组思想」是一种常见的动态规划优化方法，在我们的题目中已经多次使用到，例如「剑指 Offer 46. 把数字翻译成字符串」、「70. 爬楼梯」等，当我们定义的状态在动态规划的转移方程中只和某几个状态相关的时候，就可以考虑这种优化方法，目的是给空间复杂度「降维」。



## 序列



### ✅[斐波那契数 x](https://leetcode-cn.com/problems/fibonacci-number/)

```python
class Solution:
    def fib(self, n: int) -> int:
        if n < 2: return n
        # 1.d[i]表示第i个斐波那契数
        dp = [0 for _ in range(n+1)] 
        dp[0], dp[1] = 0, 1  # 3.初始化
        for i in range(2, n+1): # 4.确定遍历顺序
            dp[i] = dp[i-1] + dp[i-2] # 2.递推公式
        return dp[n]
```



### ✅[爬楼梯 x](https://leetcode-cn.com/problems/climbing-stairs/)

```Python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2: return n

        # 1.dp[i]表示爬到第i层阶梯的方法数
        dp = [0 for _ in range(n+1)]
        dp[1], dp[2] = 1, 2 # 3. dp数组初始化（n是正整数，不用管n=0）

        for i in range(3, n+1): # 4. 确定遍历顺序
            dp[i] = dp[i-1] + dp[i-2] # 2.爬到第i层方法数 = 爬到第i-1层的方法数（最后一步爬1个台阶） + 爬到第i-2层的方法数（最后一步爬2个台阶）
        
        return dp[n]
```



### ✅[使用最小花费爬楼梯 x](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        # 1.dp定义：第i个台阶所花费的最小体力为dp[i]
        dp = [0 for _ in range(len(cost))]
        dp[0], dp[1] = cost[0], cost[1]  # 3.初始化0, 1阶梯dp=cost

        for i in range(2, len(cost)): # 4.确定遍历顺序
            dp[i] = min(dp[i-1], dp[i-2]) + cost[i]  # 2.dp[i]是由 min(dp[i-1], dp[i-2])，然后加上爬上i阶花费的cost[i]
        
        return min(dp[-1], dp[-2]) # 到达楼顶可以看作是Min(倒数第一个阶梯，倒数第二个阶梯)，然后再加上楼顶的cost=0得到       
```



### ✅[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        for i in range(1, len(nums)):
            nums[i] = max(nums[i-1] + nums[i], nums[i])
        return max(nums)
```



### ✅[跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

```Python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        
        max_pos = nums[0] # 维护可以到达最远的位置， 能到达最远的位置说明比他小的位置都能到达
        
        for i in range(1, len(nums)):
            if max_pos < i: #如果维护最远的位置到不了i位置，提前结束
                return False
            max_pos = max(max_pos, i + nums[i]) # DP
            if maxPos >= len(nums) - 1: # 维护的最远距离大于等于nums最后一个下标，提前返回True
                return True
        
        return True
```



### ✅[跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

```Python
class Solution:
    def jump(self, nums: List[int]) -> int:
        step, curMaxStep, nextMaxStep = 0, 0 , 0 # step维护需要最少的步数 curMaxStep维护当前步数能到最远的距离，nextMaxStep维护step+1能到最远的距离

        for i in range(len(nums)):
            if i > curMaxStep:
                step += 1
                curMaxStep = nextMaxStep
            nextMaxStep = max(nextMaxStep, i + nums[i])
            
        return step
```



### [分割回文串 II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)



```Python

```



### ✅[最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

不是最长连续递增子序列

```Python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        if not nums: return 0
        dp = [1 for _ in range(len(nums))]
        for i in range(len(nums)):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```



### ✅[单词拆分](https://leetcode-cn.com/problems/word-break/)



核心是dp[i]=True表示s前i-1个能用worddict表示，s[i, j+1]在worddict里面，说明dp[j] = True

```Python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:       
        n=len(s)
        dp=[False]*(n+1)
        dp[0]=True
        for i in range(n):
            for j in range(i+1,n+1):
                if(dp[i] and (s[i:j] in wordDict)):
                    dp[j]=True
        return dp[-1]
```



小结

常见处理方式是给 0 位置占位，这样处理问题时一视同仁，初始化则在原来基础上 length+1，返回结果 f[n]

- 状态可以为前 i 个
- 初始化 length+1
- 取值 index=i-1
- 返回值：f[n]或者 f[m] [n]



##  二维DP



### [longest-common-subsequence](https://leetcode-cn.com/problems/longest-common-subsequence/)

- 二维DP若只与当前行和上一行有关，可将空间复杂度降到线性

```Python
class Solution:
    def longestCommonSubsequence(self, t1: str, t2: str) -> int:
        
        if t1 == '' or t2 == '':
            return 0
        
        if len(t1) < len(t2):
            t1, t2 = t2, t1

        dp = [int(t2[0] == t1[0])] * len(t2) # previous row
        dp_new = [0] * len(t2) # current row
        
        for j in range(1, len(t2)):
            dp[j] = 1 if t2[j] == t1[0] else dp[j - 1]
        
        for i in range(1, len(t1)):
            dp_new[0] = 1 if dp[0] == 1 or t2[0] == t1[i] else 0
            for j in range(1, len(t2)):
                if t2[j] != t1[i]:
                    dp_new[j] = max(dp[j], dp_new[j - 1])
                else:
                    dp_new[j] = dp[j - 1] + 1
            dp, dp_new = dp_new, dp
        
        return dp[-1]
```

### [edit-distance](https://leetcode-cn.com/problems/edit-distance/)

> 给你两个单词  word1 和  word2，请你计算出将  word1  转换成  word2 所使用的最少操作数  
> 你可以对一个单词进行如下三种操作：
> 插入一个字符
> 删除一个字符
> 替换一个字符

思路：和上题很类似，相等则不需要操作，否则取删除、插入、替换最小操作次数的值+1

```Python
class Solution:
    def minDistance(self, w1: str, w2: str) -> int:
        
        if w1 == '': return len(w2)
        if w2 == '': return len(w1)
        
        m, n = len(w1), len(w2)
        if m < n:
            w1, w2, m, n = w2, w1, n, m
        
        dp = [int(w1[0] != w2[0])] * n
        dp_new = [0] * n
        
        for j in range(1, n):
            dp[j] = dp[j - 1] + int(w2[j] != w1[0] or dp[j - 1] != j)
        
        for i in range(1, m):
            dp_new[0] = dp[0] + int(w2[0] != w1[i] or dp[0] != i)
            
            for j in range(1, n):
                dp_new[j] = min(dp[j - 1] + int(w2[j] != w1[i]), dp[j] + 1, dp_new[j - 1] + 1)
                
            dp, dp_new = dp_new, dp
        
        
        return dp[-1]
```

说明

> 另外一种做法：MAXLEN(a,b)-LCS(a,b)



## 零钱 & 背包



### [coin-change](https://leetcode-cn.com/problems/coin-change/)

思路：和其他 DP 不太一样，i 表示钱或者容量

```Python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        
        dp = [0] * (amount + 1)
         
        for i in range(1, len(dp)):
            dp[i] = float('inf')
            
            for coin in coins:
                if i >= coin and dp[i - coin] + 1 < dp[i]:
                    dp[i] = dp[i - coin] + 1
            
        return -1 if dp[amount] == float('inf') else dp[amount]
```


### [backpack](https://www.lintcode.com/problem/backpack/description)

> 在 n 个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为 m，每个物品的大小为 A[i]

```Python
class Solution:
    def backPack(self, m, A):
        
        n = len(A)
        
        dp = [0] * (m + 1)
        dp_new = [0] * (m + 1)
        
        for i in range(n):
            for j in range(1, m + 1):
                use_Ai = 0 if j - A[i] < 0 else dp[j - A[i]] + A[i]
                dp_new[j] = max(dp[j], use_Ai)
            
            dp, dp_new = dp_new, dp
        
        return dp[-1]

```

### [backpack-ii](https://www.lintcode.com/problem/backpack-ii/description)

> 有 `n` 个物品和一个大小为 `m` 的背包. 给定数组 `A` 表示每个物品的大小和数组 `V` 表示每个物品的价值.
> 问最多能装入背包的总价值是多大?

思路：dp(i, j) 为前 i 个物品，装入 j 背包的最大价值

```Python
class Solution:
    def backPackII(self, m, A, V):
        
        n = len(A)
        
        dp = [0] * (m + 1)
        dp_new = [0] * (m + 1)
        
        for i in range(n):
            for j in range(1, m + 1):
                use_Ai = 0 if j - A[i] < 0 else dp[j - A[i]] + V[i] # previous problem is a special case of this problem that V(i) = A(i)
                dp_new[j] = max(dp[j], use_Ai)
            
            dp, dp_new = dp_new, dp
        
        return dp[-1]

```

## 补充

### [maximum-product-subarray](https://leetcode-cn.com/problems/maximum-product-subarray/)

处理负数情况稍微有点复杂，注意需要同时 DP 正数乘积和负数乘积

```Python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        
        max_product = float('-inf')

        dp_pos, dp_neg = 0, 0
        
        for num in nums:
            if num > 0:
                dp_pos, dp_neg = max(num, num * dp_pos), dp_neg * num
            else:
                dp_pos, dp_neg = dp_neg * num, min(num, dp_pos * num)
            
            if dp_pos != 0:
                max_product = max(max_product, dp_pos)
            elif dp_neg != 0:
                max_product = max(max_product, dp_neg)
            else:
                max_product = max(max_product, 0)
            
        return max_product
```

### [decode-ways](https://leetcode-cn.com/problems/decode-ways/)

> 1 到 26 分别对应 a 到 z，给定输入数字串，问总共有多少种译码方法

常规 DP 题，注意处理edge case即可

```Python
class Solution:
    def numDecodings(self, s: str) -> int:
        
        def valid_2(i):
            if i < 1:
                return 0
            num = int(s[i-1:i+1])
            return int(num > 9 and num < 27)
        
        dp_1, dp_2 = 1, 0
        for i in range(len(s)):
            dp_1, dp_2 = dp_1 * int(s[i] != '0') + dp_2 * valid_2(i), dp_1
        
        return dp_1
```

### [best-time-to-buy-and-sell-stock-with-cooldown](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

> 给定股票每天的价格，每天可以买入卖出，买入后必须卖出才可以进行下一次购买，卖出后一天不可以购买，问可以获得的最大利润

经典的维特比译码类问题，找到状态空间和状态转移关系即可

```Python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        buy, buy_then_nothing, sell, sell_then_nothing = float('-inf'), float('-inf'), float('-inf'), 0
        
        for p in prices:
            buy, buy_then_nothing, sell, sell_then_nothing = sell_then_nothing - p, max(buy, buy_then_nothing), max(buy, buy_then_nothing) + p, max(sell, sell_then_nothing)
        
        return max(buy, buy_then_nothing, sell, sell_then_nothing)
```

### [word-break-ii](https://leetcode-cn.com/problems/word-break-ii/)

> 给定字符串和可选的单词列表，求字符串所有的分割方式

思路：此题 DP 解法容易想但并不是好做法，因为和 word-break 不同，此题需要返回所有可行分割而不是找到一组就可以。这里使用 个人推荐 backtrack with memoization。

```Python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        
        n = len(s)
        result = []
        mem = collections.defaultdict(list)
        wordDict = set(wordDict)
        
        def backtrack(first=0, route=[]):
            if first == n:
                result.append(' '.join(route))
                return True
            
            if first not in mem:
                for next_first in range(first + 1, n + 1):
                    if s[first:next_first] in wordDict:
                        route.append(s[first:next_first])
                        if backtrack(next_first, route):
                            mem[first].append(next_first)
                        route.pop()
                if len(mem[first]) > 0:
                    return True
            elif len(mem[first]) > 0:
                for next_first in mem[first]:
                    route.append(s[first:next_first])
                    backtrack(next_first)
                    route.pop()
                return True
            
            return False
        
        backtrack()
        return result
```

### [burst-balloons](https://leetcode-cn.com/problems/burst-balloons/)

> n 个气球排成一行，每个气球上有一个分数，每次戳爆一个气球得分为该气球分数和相邻两气球分数的乘积，求最大得分

此题主要难点是构造 DP 的状态，过程为逆着气球戳爆的顺序

```Python
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        
        n = len(nums)
        nums.append(1)
        dp = [[0] * (n + 1) for _ in range(n + 1)]
        
        for dist in range(2, n + 2):
            for left in range(-1, n - dist + 1):
                right = left + dist
                max_coin = float('-inf')
                left_right = nums[left] * nums[right]
                for j in range(left + 1, right):
                    max_coin = max(max_coin, left_right * nums[j] + dp[left][j] + dp[j][right])
                dp[left][right] = max_coin
        nums.pop()
        return dp[-1][n]
```
